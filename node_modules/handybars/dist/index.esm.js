/**
 * 
 * Handybars
 * 
 * Copyright (c) 2020, Jocelyn Badgley
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Portions of the MIT licensed date-fns library are bundled with this
 * software. https://github.com/date-fns/date-fns#readme
 */

const MISSING = '{!MISSING!}';

// htmlEscape copied from Sindre Sorhus' escape-goat
const htmlEscape = (input) => input
	.replace(/&/g, '&amp;')
	.replace(/"/g, '&quot;')
	.replace(/'/g, '&#39;')
	.replace(/</g, '&lt;')
	.replace(/>/g, '&gt;');

function makeContext (ctx, env, { hash = null } = {}) {
	const frame = env ? Object.create(env) : {};

	if (hash) Object.assign(frame, hash);

	frame.this = ctx;
	frame['@env'] = frame;
	frame['@value'] = ctx;
	frame['@parent'] = env;
	frame['@root'] = env['@root'] || frame;

	return frame;
}

function contextIterate (input, env, fn, hash) {
	var frame = makeContext(input, env, { hash });
	const c = sizeOf(input);
	return safeJoin(input, (value, key, index) => {
		frame.this = value;
		frame['@value'] = value;
		frame['@key'] = key;
		frame['@index'] = index;
		frame['@first'] = index === 0;
		frame['@last'] = index === c - 1;
		return fn(value, frame);
	});
}

const SAFE_NONE = 0;
const SAFE_WRAPPED = 1;
const SAFE_ESCAPED = 2;

function safe (input, level = SAFE_WRAPPED) {
	if (isUndefinedOrNull(input) || isFalse(input)) {
		if (level === SAFE_NONE) return input;
		return { value: '', safety: level };
	}
	if (isString(input)) {
		if (level === SAFE_NONE) return input;
		if (level === SAFE_WRAPPED) return { value: input, safety: level };
		if (level === SAFE_ESCAPED) return { value: input && htmlEscape(input) };
	}
	if (isObject(input) && hasOwn(input, 'value')) {
		if (level === SAFE_NONE) return input.value;
		return { value: input.value, safety: level };
	}

	if (level === SAFE_NONE) return input;
	return { value: input, safety: level };
}

safe.NONE    = SAFE_ESCAPED;
safe.WRAPPED = SAFE_WRAPPED;
safe.ESCAPED = SAFE_ESCAPED;

safe.down = (input) => safe(input, SAFE_NONE);
safe.up   = (input) => safe(input, SAFE_ESCAPED);

function safeJoin (inputs, predicate, delimiter = '') {
	predicate = iteratee(predicate);
	return { value: map(inputs, (val, k, i) => safe.up(predicate(val, k, i)).value).join(delimiter) };
}

function wtf (msg, info) {
	if (info) console.error(info); // eslint-disable-line no-console
	throw new Error(msg);
}

function equals (value) {
	value = uc(value);
	return (tok) => uc(tok) === value;
}

function anyOf (...args) {
	args = args.flat().map(uc);
	if (!anyBy(args, isFunction)) {
		// arguments do not contain a function, so we can optimize
		if (args.length === 1) return (tok) => uc(tok) === args[0];
		return (tok) => args.includes(uc(tok));
	}

	args = args.map((a) => isFunction(a) && a || equals(a));
	if (args.length === 1) return (tok) => args[0](tok);
	return (tok) => anyBy(args, (check) => check(tok));
}

function isNumber        (input) { return typeof input === 'number' && !isNaN(input); }
function isString        (input) { return typeof input === 'string'; }
function isFunction      (input) { return typeof input === 'function'; }
function isNull          (input) { return input === null; }
function isUndefined     (input) { return typeof input === 'undefined'; }
function isUndefinedOrNull (input) { return isUndefined(input) || isNull(input); }
function isNotUndefinedOrNull (input) { return !isUndefined(input) && !isNull(input); }
function isMap           (input) { return input instanceof Map; }
function isSet           (input) { return input instanceof Set; }
function isFalse         (input) { return input === false; }
const isArray = Array.isArray;

function isPrimitive (input) {
	switch (typeof input) {
	case 'string':
	case 'number':
	case 'boolean':
		return true;
	default:
		return false;
	}
}

function isObject (input) {
	if (!input) return false;
	if (typeof input !== 'object') return false;
	if (isArray(input)) return false;
	if (!(input instanceof Object)) return false;
	if (input.constructor !== Object.prototype.constructor) return false;
	return true;
}

function truthy (value) {
	if (isMappable(value)) return !!sizeOf(value);
	return !!value;
}

function falsey (value) {
	return !truthy(value);
}

function hasOwn (obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
}

function uc (str) {
	return isString(str) ? str.toUpperCase() : str;
}

function get (obj, path, defaultValue) {
	if (isUndefinedOrNull(obj) || isPrimitive(obj)) throw new TypeError('Input object was not a collection.');
	if (isUndefinedOrNull(path) || path === '') return false;
	if (isNumber(path)) path = [ String(path) ];
	else if (isString(path)) {
		if (hasOwn(obj, path)) return obj[path];
		path = path.split(/[,[\].]+?/);
	}

	const result = path
		.filter((s) => isNotUndefinedOrNull(s) && s !== '')
		.reduce((res, key) =>
			((isNotUndefinedOrNull(res)) ? res[key] : res)
		, obj);
	return (isUndefined(result) || result === obj) ? defaultValue : result;
}

function has (obj, path) {
	if (isUndefinedOrNull(path) || path === '') return false;
	if (isNumber(path)) path = [ String(path) ];
	else if (isString(path)) path = String.prototype.split.call(path, /[,[\].]+?/);
	let res = obj;
	for (const key of path) {
		if (
			isUndefinedOrNull(res)
			|| (typeof res !== 'object' && isFunction(res))
			|| isUndefined(res[key])
		) return false;
		res = res[key];
	}
	return true;
}

function set (obj, path, value) {
	if (isUndefinedOrNull(path) || path === '') return false;
	if (isNumber(path)) path = [ String(path) ];
	else if (isString(path)) {
		if (hasOwn(obj, path)) {
			obj[path] = value;
			return obj;
		}
		path = path.split(/[,[\].]+?/);
	}

	const c = path.length - 1;
	path
		.filter((s) => s || s === 0)
		.reduce((res, key, i) => {
			if (i === c) {
				res[key] = value;
				return true;
			}
			if (isObject(res[key]) || isFunction(res[key])) return res[key];
			return (res[key] = {});
		}, obj);

	return obj;
}


function isMappable (collection, arrays = true) {
	return (
		(arrays && isArray(collection)) ||
		(arrays && isSet(collection)) ||
		isMap(collection) ||
		collection && (typeof collection === 'object' || typeof collection === 'function')
	);
}

function sizeOf (collection) {
	if (isArray(collection) || isString(collection)) return collection.length;
	if (isSet(collection) || isMap(collection)) return collection.size;
	if (isObject(collection)) return Object.keys(collection).length;
	return !!collection;
}

function arrayify (input) {
	if (isArray(input)) return input;

	if (isSet(input) || isMap(input)) return Array.from(input.values());

	if (isObject(input)) return Object.values(input);

	if (isString(input)) return input.split(/,\s*/);

	return [ input ];
}

function all (...args) {
	let input;
	if (args.length > 1) {
		input = args;
	} else {
		input = arrayify(args[0]);
	}

	let result = input.shift();
	for (const value of input) {
		if (!truthy(result)) {
			return false;
		}
		result = value;
	}

	return result;
}

function anyBy (collection, predicate = null) {
	if (!collection) return false;
	if (predicate === null) {
		predicate = (v) => v;
	} else if (!isFunction(iteratee)) {
		predicate = iteratee(predicate);
	}

	if (isArray(collection)) {
		let i = 0;
		for (const value of collection) {
			if (predicate(value, i, i++)) return true;
		}
		return false;
	}

	if (isSet(collection)) {
		let i = 0;
		for (const item of collection) {
			if (predicate(item, i, i++)) return true;
		}
		return false;
	}

	// received a Map
	if (isMap(collection)) {
		let i = 0;
		for (const [ key, value ] of collection.entries()) {
			if (predicate(value, key, i++)) return true;
		}
		return false;
	}

	// received an object hash
	if (isObject(collection)) {
		let i = 0;
		for (const [ key, value ] of Object.entries(collection)) {
			if (predicate(value, key, i++)) return true;
		}
		return false;
	}

	return !!collection;
}

function iteratee (match) {
	if (isUndefinedOrNull(match)) return (v) => v;

	if (isFunction(match)) return match;

	if (isString(match)) {
		return (o) => {
			if (isArray(o)) return o.includes(match);
			if (isObject(o)) return o[match];
			if (isMap(o)) return o.get(match);
			if (isSet(o)) return o.has(match);
			if (isPrimitive(o)) return o[match];
			return o === match;
		};
	}

	if (isNumber(match)) {
		return (o) => {
			if (isObject(o) || isArray(o)) return o[match];
			if (isMap(o)) return o.get(match);
			if (isSet(o)) return o.has(match);
			if (isNumber(o)) return o === match;
			if (isString(o)) return Number(o) === match;
			return o === match;
		};
	}

	if (isArray(match)) {
		const [ key, value ] = match;
		return (o) => o[key] === value;
	}

	if (isObject(match)) {
		// create an array of key/value iteratees
		const tests = Object.entries(match).map(iteratee);
		// evaluate the object against the array
		return (o) => {
			for (const t of tests) {
				if (!t(o)) return false;
			}
			return true;
		};
	}
}

function toPairs (object) {
	return Object.entries(object);
}

function fromPairs (entries) {
	return mapReduce(entries, ([ v, k ]) => [ v, k ]);
}

function slice (collection, begin, end) {
	if (isString(collection) || isArray(collection)) return collection.slice(begin, end);

	if (isSet(collection)) {
		return new Set(Array.from(collection.values()).slice(begin, end));
	}

	if (isMap(collection)) {
		return new Map(Array.from(collection.entries()).slice(begin, end));
	}

	if (isObject(collection)) {
		return fromPairs(toPairs(collection).slice(begin, end));
	}

	return collection;
}

function map (collection, predicate) {
	predicate = iteratee(predicate);

	if (isArray(collection)) {
		return collection.map((value, i) => predicate(value, i, i));
	} else if (isSet(collection)) {
		return Array.from(collection, (value, i) => predicate(value, i, i));
	} else if (isMap(collection)) {
		return Array.from(collection.entries(), ([ key, value ], index) => predicate(value, key, index));
	} else if (isObject(collection)) {
		return Object.entries(collection).map(([ key, value ], index) => predicate(value, key, index));
	} else if (isString(collection)) {
		return collection.split().map((value, i) => predicate(value, i, i));
	}

	return [];
}

function makeIterate (predicate, tuple = false) {
	predicate = iteratee(predicate);
	const result = {};
	function iterate (val, k, i) {
		// return true to continue looping
		const res = predicate(val, k, i) || [];
		if (tuple) {
			if (res === false) return false;
			if (!res || !isArray(res)) return true;
			const [ key, value ] = res;
			if (isUndefinedOrNull(key) || isUndefined(value)) return true;
			result[key] = value;
		} else {
			result[k] = res;
		}
		return true;
	}

	iterate.result = () => result;

	return iterate;
}

function mapValues (collection, predicate) {
	if (!isObject(collection)) throw new Error('mapValues only works for simple objects, use mapReduce.');
	const iterate = makeIterate(predicate);

	let i = 0;
	for (const [ key, value ] of Object.entries(collection)) {
		if (!iterate(value, key, i++)) break;
	}
	return iterate.result();
}

/**
 * Iterates over a collection and generates an object based on tuple returned from the iteratee.
 * @param  {Object|Array|Map|Set} collection
 * @param  {Function} iteratee Callback invoked for each item, receives `value, key, index`, returns `[key, value]`;
 * @return {Object}
 */
function mapReduce (collection, predicate) {
	if (!collection) return {};

	const iterate = makeIterate(predicate, true);

	if (isArray(collection)) {
		let i = 0;
		for (const value of collection) {
			if (!iterate(value, i, i++)) break;
		}
	} else if (isSet(collection)) {
		let i = 0;
		for (const item of collection) {
			if (!iterate(item, i, i++)) break;
		}
	} else if (isMap(collection)) {
		let i = 0;
		for (const [ key, value ] of collection.entries()) {
			if (!iterate(value, key, i++)) break;
		}
	} else if (isObject(collection)) {
		let i = 0;
		for (const [ key, value ] of Object.entries(collection)) {
			if (!iterate(value, key, i++)) break;
		}
	}

	return iterate.result();
}

function reduce (collection, predicate, init) {
	if (!isFunction(predicate)) throw new TypeError('Predicate must be a function');

	if (isArray(collection)) return collection.reduce((r, v, i) => predicate(r, v, i, i), init);

	if (isSet(collection)) {
		return Array.from(collection).reduce((r, v, i) => predicate(r, v, i, i), init);
	}

	if (isMap(collection)) {
		return Array.from(collection.entries()).reduce((prev, [ key, value ], i) => predicate(prev, value, key, i), init);
	}

	if (isObject(collection)) {
		return Object.entries(collection).reduce((prev, [ key, value ], i) => predicate(prev, value, key, i), init);
	}
}

function flatten (collection, depth = Infinity) {
	if (depth <= 0) return slice(collection);
	return reduce(collection,
		(acc, val) => acc.concat(...(
			isMappable(val)
				? flatten(val, depth - 1)
				: [ val ]
		)),
		[],
	);
}

const T_WHITESPACE    = 0;
const T_TEXT          = 1;
const T_BLOCK_OPEN    = 2;
const T_BLOCK_STOP    = 3;
const T_BLOCK_START   = 4;
const T_BLOCK_CLOSE   = 5;
const T_ELSE          = 6;
const T_IDENTIFIER    = 7;
const T_LITERAL_NUM   = 8;
const T_LITERAL_STR   = 9;
const T_LITERAL_PRI   = 10;
const T_BRACKET_OPEN  = 11;
const T_BRACKET_CLOSE = 12;
const T_PAREN_OPEN    = 13;
const T_PAREN_CLOSE   = 14;
const T_ASSIGNMENT    = 15;

const T = [
	'WHITESPACE',
	'TEXT',
	'BLOCK_OPEN',
	'BLOCK_STOP',
	'BLOCK_START',
	'BLOCK_CLOSE',
	'ELSE',
	'IDENTIFIER',
	'LITERAL_NUM',
	'LITERAL_STR',
	'LITERAL_PRI',
	'BRACKET_OPEN',
	'BRACKET_CLOSE',
	'PAREN_OPEN',
	'PAREN_CLOSE',
	'ASSIGNMENT',
];

const LF            = 10;
const CR            = 13;
const SPACE         = 32;
const NBSP          = 160;
const CURL_OPEN     = 123;// {
const CURL_CLOSE    = 125;// }
const BRACKET_OPEN  = 91; // [
const BRACKET_CLOSE = 93; // ]
const PAREN_OPEN    = 40; // (
const PAREN_CLOSE   = 41; // )
const HASH          = 35; // #
const SLASH         = 47; // /
const BACKSLASH     = 92; // \
const DOLLAR        = 36; // $
const EQUAL         = 61; // =
const AT            = 64; // @
const UNDERSCORE    = 95; // _
const PERIOD        = 46; // .
const MINUS         = 45; // -
const QUOT          = 39; // '
const DOUBLEQUOT    = 34; // "

const isAlpha = (char) => (char >= 65 && char <= 90) || (char >= 97 && char <= 122);
const isNumeric = (char) => (char >= 48 && char <= 57);
const isIdent = anyOf(isAlpha, isNumeric, UNDERSCORE, AT, DOLLAR, PERIOD);
const isMinusPeriod = (char) => (char === MINUS || char === PERIOD);
const isQuot = (char) => (char === QUOT || char === DOUBLEQUOT);

function tokenizer (input) {
	const max = input.length - 1;
	let inside = false;
	let pos = 0;
	let line = 1;
	let col = 1;

	const tokens = [];
	let tindex = -1;

	function token (type, contents = null, l = line, c = col) {
		const tok = { type, contents, line: l, column: c };
		tokens.push(tok);
		return tok;
	}

	const err = new SyntaxError();
	function wtf (msg, { l = line, c = col, ...extra } = {}) {
		err.message = msg + ` (${l}:${c})`;
		console.dir(tokens); // eslint-disable-line no-console
		throw Object.assign(err, extra, { line: l, column: c });
	}

	function plc () { return { p: pos, l: line, c: col }; }

	function matchWord (value) {
		return input.startsWith(value, pos);
	}

	function peek (delta = 0) {
		const i = pos + delta;
		if (i > max || i < 0) return;
		return input.charCodeAt(i);
	}

	function parseChar (char) {
		if (char === CR || char === LF) {
			line++;
			col = 1;
			// account for CRLF
			if (char === CR && input.charCodeAt(pos) === LF) {
				pos++;
			}
		} else {
			col++;
		}
	}

	function move (delta = 1) {
		const index = Math.min(max + 1, Math.max(0, pos + delta));
		if (delta > 0) for (let i = pos; i < index; i++) parseChar(input.charCodeAt(i));
		pos = index;
		return pos <= max;
	}

	function eof () {
		return pos > max;
	}

	function readRaw () {
		if (inside) return;
		let char = peek();
		const { p, l, c } = plc();
		do {
			if (char === CURL_OPEN && peek(1) === CURL_OPEN) break;
			move();
		} while ((char = peek()));
		if (p === pos) return;
		token(T_TEXT, input.slice(p, pos), l, c);
		return true;
	}

	function readBlockStart () {
		if (inside || peek(0) !== CURL_OPEN || peek(1) !== CURL_OPEN) return;
		inside = true;
		const tok = token(T_BLOCK_START, '{{');
		if (peek(2) === CURL_OPEN) {
			tok.raw = true;
			tok.contents = '{{{';
			move(3);
		} else move(2);
		if (peek() === HASH) {
			token(T_BLOCK_OPEN, '#');
			move(1);
		} else if (peek() === SLASH) {
			token(T_BLOCK_CLOSE, '/');
			move(1);
		} else if (matchWord('else') || matchWord('ELSE')) {
			token(T_ELSE, 'else');
			move(4);
		}
		return true;
	}

	function readBlockEnd () {
		if (!inside || peek(0) !== CURL_CLOSE || peek(1) !== CURL_CLOSE) return;
		inside = false;
		const tok = token(T_BLOCK_STOP, '}}');
		if (peek(2) === CURL_CLOSE) {
			tok.raw = true;
			tok.contents = '}}}';
			move(3);
		} else move(2);
		return true;
	}

	function readWhitespace () {
		if (!inside) return;
		const { p, l, c } = plc();
		let char;
		while (pos <= max && (char = peek(0))) {
			if (char > 14 && char !== SPACE && char !== NBSP) break;
			move();
		}
		if (p === pos) return;
		token(T_WHITESPACE, input.slice(p, pos), l, c);
		return true;
	}

	function readParenStart () {
		if (!inside || peek() !== PAREN_OPEN) return;
		token(T_PAREN_OPEN, '(');
		move();
		return true;
	}

	function readParenEnd () {
		if (!inside || peek() !== PAREN_CLOSE) return;
		token(T_PAREN_CLOSE, ')');
		move();

		// If the paren is followed by a period, then we are accessing something off the result
		if (peek() === PERIOD) move();
		return true;
	}


	function readBrackStart () {
		if (!inside || peek() !== BRACKET_OPEN) return;
		token(T_BRACKET_OPEN, '[');
		move();
		return true;
	}

	function readBrackEnd () {
		if (!inside || peek() !== BRACKET_CLOSE) return;
		token(T_BRACKET_CLOSE, ']');
		move();
		if (peek() === PERIOD) move();
		return true;
	}


	function readAssignment () {
		if (!inside || peek() !== EQUAL) return;
		token(T_ASSIGNMENT, '=');
		move();
		return true;
	}

	function readIdentifier () {
		let char = peek();
		if (!inside || isNumeric(char) || !isIdent(char) || char === PERIOD) return;
		const { p, l, c } = plc();
		move();
		while ((char = peek())) {
			if (!isIdent(char)) break;
			move();
		}
		if (p === pos) return;
		const contents = input.slice(p, pos);
		if (contents === 'true')       token(T_LITERAL_PRI, true, l, c);
		else if (contents === 'false') token(T_LITERAL_PRI, false, l, c);
		else if (contents === 'null')  token(T_LITERAL_PRI, null, l, c);
		else token(T_IDENTIFIER, contents, l, c);
		return true;
	}

	function readNumber () {
		if (!inside) return;
		let char = peek();
		if (!isNumeric(char) && !isMinusPeriod(char)) return;
		if (isMinusPeriod(char) && !isNumeric(peek(1))) return;
		const { p, l, c } = plc();
		let hasPeriod = false;

		do {
			if (char === MINUS) {
				if (pos !== p) break;
				move();
				continue;
			}
			// found a minus after the start of the number, this is not part of the token.

			if (char === PERIOD) {
				if (hasPeriod) break; // we found an extra period, not part of the token.
				hasPeriod = true;
			} else if (!isNumeric(char)) break;
			// found something that was neither number nor period, not part of the token.

			move();
		} while ((char = peek()));

		if (p === pos) return;
		token(T_LITERAL_NUM, input.slice(p, pos), l, c);
		return true;
	}

	function readString () {
		let char = peek();
		if (!inside || !isQuot(char)) return;
		const { p, l, c } = plc();
		const fence = char;
		move();
		while ((char = peek())) {
			if (char === BACKSLASH) {
				move(2);
				continue;
			}
			if (char === fence) {
				token(T_LITERAL_STR, pos - p === 1 ? '' : input.slice(p + 1, pos).replace(/\\(.)/, '$1'),  l, c);
				move();
				return true;
			}
			move();
		}
		wtf(`Unterminated string literal: ${input.substr(p, 20)}…`, { l, c });
	}

	function read () {
		if (eof()) return false;
		for (const r of read.order) {
			// console.log(r, pos);
			if (r()) return true;
		}
		wtf(`Unknown token: ${input.substr(pos, 20)}…`);
	}
	read.order = [
		readBlockStart,
		readRaw,
		readWhitespace,
		readIdentifier,
		readNumber,
		readString,
		readAssignment,
		readBrackStart,
		readBrackEnd,
		readParenStart,
		readParenEnd,
		readBlockEnd,
	];

	return {
		get eof () {
			return eof();
		},
		get current () {
			while (tindex >= tokens.length && !eof()) read();
			return tokens[tindex];
		},
		readAll () {
			while (read());
			return tokens;
		},
		reset () {
			tindex = -1;
			return this;
		},
		next () {
			tindex++;
			while (tindex >= tokens.length && !eof()) read();
			return tokens[tindex];
		},
		peek (delta = 1) {
			const idx = tindex + delta;
			while (idx >= tokens.length && !eof()) read();
			return tokens[idx];
		},

	};
}

class Node {
	constructor () { this._type = 'Node'; }
	evaluate () { return null; }
}

class Text extends Node {
	constructor (value = '') {
		super();
		this.value = value;
		this._type = 'Text';
	}

	evaluate () {
		return { value: this.value };
	}
}

class Block extends Node {
	constructor ({ type, invoker, left, right, raw, ...props }) {
		super();
		Object.assign(this, props);
		this.type = type;
		this.invoker = invoker || null;
		this.left = left || null;
		this.right = right || null;
		this.raw = raw || false;
		this._type = 'Block';
	}

	_descender (tree, ctx, env) {
		if (!tree || !tree.length) return null;
		return (subctx = ctx, e = env) => {
			if (e === env && subctx !== ctx) e = makeContext(subctx, e);
			return render(tree, subctx, e);
		};
	}

	evaluate (ctx, env = {}) {
		const fn = this._descender(this.left, ctx, env);
		const inverse = this._descender(this.right, ctx, env);
		const children = this.left && this.left.length ? this.left : null;

		var result = this.invoker
			? this.invoker.evaluate(ctx, env, { fn, inverse, children })
			: fn && fn(ctx) || undefined
		;

		return this.raw ? safe(result) : safe.up(result);
	}
}

class Invocation extends Node {
	constructor (props = {}) {
		super();
		Object.assign(this, props);
		this.arguments = props.arguments || [];
		this.hash = props.hash || {};
		this._type = 'Invocation';
	}

	evaluate (ctx, env = {}, { fn, inverse, children } = {}) {
		if (!this.arguments.length) return ''; // this shouldn't happen
		let [ target, ...args ] = this.arguments;
		target = target.evaluate(ctx, env);

		const hash = this.hashCount ? mapValues(this.hash, (a) => safe.down(a.evaluate(ctx, env))) : {};

		if (target && isFunction(target.evaluate)) {
			const source = args.length ? args[0] : ctx;
			const frame = makeContext(source, env, { hash });
			if (children) frame['@partial-block'] = new Block({ type: '@partial-block', left: children });
			return target.evaluate(source, frame);
		}

		if (!isFunction(target)) {
			if (target && fn) return fn(ctx, env);
			if (!target && inverse) return inverse(ctx, env);
			if (fn && inverse) return target ? fn(ctx, env) : inverse(ctx, env);
			return target;
		}

		args = args.map((a) => safe.down(a.evaluate(ctx, env)));
		return target(...args, {
			ctx,
			env,
			fn,
			inverse,
			arguments: args,
			hash,
			resolve: (what) => resolve(what, ctx, env),
		});
	}

	set (key, value) {
		this.hash[key] = value;
		this.hashCount = (this.hashCount || 0) + 1;
		return this;
	}
}

class Collection extends Invocation {
	constructor (args) {
		super();
		this.arguments = args || [];
		this._type = 'Collection';
	}

	evaluate (ctx, env = {}) {
		return this.arguments.map((a) => a.evaluate(ctx, env));
	}
}

class Identifier extends Node {
	constructor (target, critical) {
		super();
		this.target = target;
		this.critical = !!critical;
		this._type = 'Identifier';
	}

	evaluate (ctx, env = {}) {
		return resolve(this.target, ctx, env, this.critical);
	}
}

class CompoundIdentifier extends Node {
	constructor (target, args = [], critical = false) {
		super();
		this.path = target.split(/[,[\].]+?/).filter(Boolean).map((i) => new Identifier(i));
		this.refs = [];
		this.critical = critical;
		this._type = 'CompoundIdentifier';

		for (const arg of args) {
			if (arg.r) this.pushRef(arg.r);
			else this.pushTarget(arg);
		}
	}

	evaluate (ctx, env = {}) {
		const refs = this.refs.map((spec) => safe.down(spec.evaluate(ctx, env, this.critical)));
		const path = this.path.map((spec) => {
			if (spec.ref !== undefined) {
				spec = refs[spec.ref];
			}
			if (spec.evaluate) {
				return safe.down(spec.evaluate(ctx, env, this.critical));
			}
			return spec;
		});

		const target = path.shift();
		if (!target) return;

		const result = get(target, path, MISSING);
		return result === MISSING ? undefined : result;
	}

	pushRef (spec) {
		this.refs.push(spec);
		this.path.push({ ref: this.refs.length - 1 });
	}

	pushTarget (spec) {
		this.path.push(spec);
	}
}

class Literal extends Node {
	constructor (value, type = T_LITERAL_PRI) {
		super();
		this.value = value;
		this.type = type;
		this._type = 'Literal';
	}

	evaluate () {
		if (this.type === T_LITERAL_NUM) return parseFloat(this.value);
		return this.value;
	}
}

function render (children, ctx, env) {
	if (!Array.isArray(children) || !children.length) return '';
	const value = children
		.map((c) => safe.up(c.evaluate(ctx, env)))
		.filter((c) => c.value !== '')
		.map((c) => c.value)
		.join('');
	return { value };
}


function resolve (what, ctx, env, needed = false) {
	let target;
	if (!isUndefinedOrNull(ctx)  && !isPrimitive(ctx) && (target = get(ctx, what, MISSING)) !== MISSING) return target;
	if (!isUndefinedOrNull(env)    && (target = get(env, what, MISSING)) !== MISSING) return target;

	let parent = env;
	while ((parent = parent['@parent'])) {
		if (!isUndefinedOrNull(parent.this) && !isPrimitive(parent.this) && (target = get(parent.this, what, MISSING)) !== MISSING) return target;
		if (!isUndefinedOrNull(parent)      && (target = get(parent, what, MISSING)) !== MISSING) return target;
	}

	if (needed) wtf(`Could not resolve "${what}"`);
	return;
}

function lex (input, debug) {
	const tokens = tokenizer(input);
	let tok, contents;
	let tindex = 0;

	function next (type, required) {
		if (tokens.eof) return;
		const t = tokens.peek();
		if (!isUndefined(type) && t && t.type !== type) {
			if (required) wtf(isString(required) ? required : `Expected ${type} but found ${T[t.type]}`, t);
			return;
		}
		contents = t.contents;
		tindex++;
		return (tok = tokens.next());
	}

	function peek (type, delta = 1) {
		const t = tokens.peek(delta);
		if (!isUndefined(type) && t && t.type !== type) return;
		return t;
	}


	const err = new SyntaxError();
	function wtf (msg = 'Unexpected token: ' + T[tok.type], { line, column, ...extra } = tok || {}) {
		msg += (line ? ` (${line}:${column})` : '');
		if (debug) msg += `[Token ${tindex}]`;
		let e = err;
		if (debug) e = new SyntaxError(msg);
		else err.message = msg;
		throw Object.assign(e, extra);
	}

	const is = (type) => (t = tok) => t && t.type === type;
	const isIdentifier   = is(T_IDENTIFIER);
	const isText         = is(T_TEXT);
	const isWhitespace   = is(T_WHITESPACE);
	const isBlockStart   = is(T_BLOCK_START);
	const isBlockStop    = is(T_BLOCK_STOP);
	const isBracketOpen  = is(T_BRACKET_OPEN);
	const isBracketClose = is(T_BRACKET_CLOSE);
	const isParenOpen    = is(T_PAREN_OPEN);
	const isParenClose   = is(T_PAREN_CLOSE);
	const isAssignment   = is(T_ASSIGNMENT);
	const isLiteralNum   = is(T_LITERAL_NUM);
	const isLiteralStr   = is(T_LITERAL_STR);
	const isLiteralPri   = is(T_LITERAL_PRI);
	const isLiteral = (t = tok) => isLiteralNum(t) || isLiteralStr(t) || isLiteralPri(t);

	function descendBlock (raw) {
		let isRoot = false;
		if (!tok) {
			isRoot = true;
		} else if (!isIdentifier()) wtf(`Block helpers must start with a variable identifier, found "${tok.contents}" (${T[tok.type]})`);

		const block = new Block({
			type: isRoot ? 'ROOT' : contents,
			invoker: isRoot ? null : descendInvocation(),
			left: [],
		});
		if (raw) block.raw = raw;

		let children = block.left;

		while (next()) {
			if (isText()) {
				children.push(new Text(contents));
				continue;
			}

			if (isBlockStart()) {
				const r = tok.raw;
				if (next(T_BLOCK_OPEN)) {
					next();
					children.push(descendBlock(r));
				} else if (next(T_ELSE)) {
					if (!children.length) children.push(new Text());
					children = block.right = [];
					while (next(T_WHITESPACE)); // allow whitespace in the end of closing tags
					next(T_BLOCK_STOP, `Expected }}, found "${tok.contents}" (${T[tok.type]})`);
				} else if (next(T_BLOCK_CLOSE)) {
					next(T_IDENTIFIER, `The first argument of a block must be an identifier, found "${tok.contents}" (${T[tok.type]})`);
					if (contents !== block.type) wtf(`Expected {{/${block.type}}} but found {{/${contents}}}`);
					if (!children.length) children.push(new Text());
					while (next(T_WHITESPACE)); // allow whitespace in the end of closing tags
					next(T_BLOCK_STOP, `Expected }}, found "${tok.contents}" (${T[tok.type]})`);
					return block;
				} else if (next(T_IDENTIFIER)) {
					children.push(new Block({
						type: contents,
						invoker: descendInvocation(),
						raw: r,
					}));
				} else wtf(`This shouldn't have happened. "${peek().contents}" (${T[peek().type]})`);
				continue;
			}

			wtf(`Unexpected token while processing block children for {{#${block.type}}}: "${tok.contents}" (${T[tok.type]})`);
		}

		if (!isRoot) wtf(`Unexpected end of template, unclosed {{#${block.type}}}`);
		return block;
	}

	function descendInvocation (embedded = false) {
		const invocation = new Invocation();
		const children = invocation.arguments;

		let assigning = false;
		do {
			if (children.length && embedded) children[0].critical = true;

			if (isWhitespace()) continue;

			if (isIdentifier()) {
				if (peek(T_BRACKET_OPEN)) {
					if (assigning) {
						invocation.set(assigning, descendCompoundIdent(contents));
						assigning = false;
					} else {
						children.push(descendCompoundIdent(contents));
					}
				} else if (assigning) {
					invocation.set(assigning, new Identifier(contents));
					assigning = false;
				} else {
					children.push(new Identifier(contents));
				}
				continue;
			}

			if (isBlockStop()) {
				if (children.length > 1) children[0].critical = true;
				return invocation;
			}

			if (!children.length) wtf(`Block helpers must start with a variable identifier, found "${tok.contents}" (${T[tok.type]})`);

			if (isParenOpen()) {
				next();
				if (assigning) {
					invocation.set(assigning, descendInvocation(true));
					assigning = false;
				} else {
					children.push(descendInvocation(true));
				}
				continue;
			}

			if (isLiteral()) {
				if (assigning) {
					invocation.set(assigning, new Literal(contents, tok.type));
					assigning = false;
				} else {
					children.push(new Literal(contents, tok.type));
				}
				continue;
			}

			if (isBracketOpen()) {
				if (assigning) {
					invocation.set(assigning, descendCollection());
					assigning = false;
				} else {
					children.push(descendCollection());
				}
				continue;
			}

			if (assigning) wtf();

			if (isParenClose()) {
				if (!embedded) wtf();
				return invocation;
			}

			if (isAssignment()) {
				const last = children.pop();
				assigning = last.target;
				continue;
			}

			wtf();
		} while (next());

		if (embedded) wtf('Unexpected end of token stream, unclosed nested invocation.');
		return invocation;
	}

	function descendCompoundIdent (initial) {
		const ident = new CompoundIdentifier(initial);

		let ref = false;
		while (next()) {

			if (isWhitespace()) {
				break;
			}

			if (isBracketClose()) {
				const nt = peek();
				// ]. or ][ is a continuation of the cIdent
				if (isBracketOpen(nt) || isIdentifier(nt)) {
					continue;
				}
				break;
			}

			if (isIdentifier()) {
				if (next(T_BRACKET_OPEN)) {
					ident.pushRef(descendCompoundIdent(contents));
				} if (ref) {
					ref = false;
					ident.pushRef(new Identifier(contents));
				} else {
					ident.pushTarget(contents);
				}

				const nt = peek();
				if (isBracketOpen(nt) || isBracketClose(nt)) {
					continue;
				}
				break;
			}

			if (isParenOpen()) {
				ident.pushRef(descendInvocation(true));
				continue;
			}

			if (isLiteral()) {
				ident.pushTarget(new Literal(contents, tok.type));
				continue;
			}

			if (isBracketOpen()) {
				ref = true;
				continue;
			}

			break;
		}

		return ident;
	}

	function descendCollection () {
		const collection = new Collection();
		const children = collection.arguments;

		while (next()) {

			if (isWhitespace()) continue;

			if (isBracketClose()) {
				return collection;
			}

			if (isParenOpen()) {
				children.push(descendInvocation(true));
				continue;
			}

			if (isIdentifier()) {
				if (next(T_BRACKET_OPEN)) {
					children.push(descendCompoundIdent(contents));
				} else {
					children.push(new Identifier(contents));
				}
				continue;
			}

			if (isLiteral()) {
				children.push(new Literal(contents, tok.type));
				continue;
			}

			if (isBracketOpen()) {
				children.push(descendCollection());
				continue;
			}

			wtf();
		}

		wtf('Unexpected end of token stream, unclosed collection.');
	}

	const result = descendBlock();
	if (!tokens.eof) wtf('There are still tokens left, how did we get here?');
	return result;
}

/**
 * Evaluates the block contents if the passed input is truthy.
 *
 * @category default
 *
 * @signature {{#if input [target]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/if}}
 * @param  {mixed} input Value to test.
 * @param  {mixed} target Value to test against (strict equality). If omitted, helper will check if `input` is truthy.
 * @example
 * // name = { first: 'John', last: 'Doe' }
 * {{#if name}}<span>{{first}} {{last}}</span>{{/if}}
 * // Result: <span>John Doe</span>
 */
function _if (...args) {
	if (args.length < 1) throw new Error('Helper "if" needs a minimum of 1 arguments');
	const { ctx, fn, inverse } = args.pop();
	const value = args.shift();
	const result = args.length ? value === args[0] : truthy(value);
	if (!fn) return result || '';
	return result ? fn(ctx) : inverse && inverse();
}

/**
 * Evaluates the block contents with a new scope.
 *
 * @category default
 *
 * @signature {{#with input}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/with}}
 * @example
 * // name = { first: 'John', last: 'Doe' }
 * {{#with name}}<span>{{first}} {{last}}</span>{{/with}}
 * // Result: <span>John Doe</span>
 */
function _with (...args) {
	const { env, fn, inverse, hash } = args.pop();
	if (!fn && !inverse) return '';
	if (!args.length) return '';
	const [ ctx ] = args;
	const frame = makeContext(ctx, env, { hash });
	return truthy(ctx) ? fn(ctx, frame) : inverse && inverse();
}

/**
 * Tests if all of the values in the provided array or object are truthy.
 * May be used inline or as a conditional block.
 *
 * @category collections,logic,default
 * @signature {{all input}}
 * @param  {array<mixed>|object<mixed>} input Array whose values must all be truthy,
 * or an object whose properties must all be truthy
 * @return {boolean}
 *
 * @signature {{#all input}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/all}}
 * @example
 * {{#all flags}}All flags are true.{{else}}Some or none of the flags are true.{{/all}}
 *
 * @signature {{all arg1 [... argN]}}
 * @param {mixed} [argN] Some value to be checked for truthiness
 * @return {mixed} Returns the first last argument if all are truthy, or else an empty string.
 *
 * @signature {{#all arg1 [... argN]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/all}}
 * @describe Truthy block will evaluate if all values are truthy. ({this}).
 * @param {mixed} [argN] Some value to be checked for truthiness
 */
function all$1 (...args) {

	const { fn, inverse } = args.pop();

	if (!args.length) {
		throw new Error('Helper "all" needs 1 parameter');
	}

	const result = all(...args);

	if (!fn) return result || '';

	return result ? fn(result) : inverse && inverse(this);
}

/**
 * Tests if any of the values in the provided array or object are truthy.
 * May be used inline or as a conditional block.
 *
 * @category collections,logic,default
 * @signature {{any input}}
 * @param  {array<mixed>|object<mixed>} input Array containing any truthy
 * values, or an object with any property that is truthy
 * @return {boolean}
 *
 * @signature {{#any input}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/any}}
 * @example
 * {{#any flags}}Sore or all flags are true.{{else}}None of the flags are true.{{/any}}
 *
 * @signature {{any arg1 [... argN]}}
 * @param {mixed} [argN] Some value to be checked for truthiness
 * @return {boolean} Returns the first truthy value, or an empty string.
 *
 * @signature {{#any arg1 [... argN]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/all}}
 * @describe Truthy block will evaluate if any of the values are truthy.
 * @param {mixed} [argN] Some value to be checked for truthiness
 */
function any (...args) {
	const { fn, inverse } = args.pop();

	if (!args.length) {
		throw new Error('Helper "any" needs 1 parameter');
	}

	let input;
	if (args.length > 1) {
		input = args;
	} else {
		input = arrayify(args[0]);
	}

	let result = false;
	for (const value of input) {
		if (truthy(value)) {
			result = value;
			break;
		}
	}

	if (!fn) return result || '';

	return result ? fn(result) : inverse && inverse();
}

/**
 * Evaluates the block contents for each item in a collection.
 * May be used inline or as an iterator.
 *
 * @category collections,logic,default
 *
 * @signature {{#each input [count]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/each}}
 * @example
 * // items = ['a','b','c','d','e','f']
 * {{#each items 2}}<span>{{this}}</span>{{/each}}
 * // Result: <span>c</span><span>d</span><span>e</span><span>f</span>
 */
function each (collection, ...args) {
	const { env, fn, inverse, hash } = args.pop();

	const c = sizeOf(collection);
	if (!c) return inverse ? inverse() : collection;
	if (!fn) return collection;

	return contextIterate(collection, env, fn, hash);
}

/**
 * Returns the value at the object path defined via arguments
 * @category objects
 *
 * @signature {{get object path}}
 * @param  {object} value Value to test
 * @param  {string|Array<string>} path Path of the value to retrieve
 * @return {mixed}
 *
 * @signature {{#get value}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/get}}
 * @describe Truthy block will evaluate with the result value as the current context ({this}).
 */

function get$1 (...args) {
	if (args.length < 3) {
		throw new Error('Helper "get" needs a minimum of 3 arguments');
	}

	const { fn, inverse } = args.pop();
	const value = args.shift();
	if (!value) return '';

	if (args.length === 1) {
		args = args[0];
	} else {
		args = flatten(args);
	}

	const result = get(value, args, MISSING);
	if (result === MISSING) return inverse ? inverse() : '';
	return fn ? fn(result) : result;
}

/**
 * Tests if a value exists at the object path defined via arguments
 * @category objects
 *
 * @signature {{get object path}}
 * @param  {object} value Value to test
 * @param  {string|Array<string>} path Path of the value to retrieve
 * @return {boolean}
 *
 * @signature {{#has value}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/has}}
 * @describe Truthy block will evaluate with the result value as the current context ({this}).
 */

function has$1 (...args) {
	if (args.length < 3) {
		throw new Error('Helper "has" needs a minimum of 3 arguments');
	}

	const { fn, inverse } = args.pop();
	const value = args.shift();
	if (args.length === 1) {
		args = args[0];
	} else {
		args = flatten(args);
	}

	const result = has(value, args);
	if (!fn) return result || '';
	return result ? fn() : inverse && inverse();
}

/**
 * Tests if the first argument matches any of the other arguments with strict equality.
 *
 * @category logic,default
 *
 * @signature {{is value test1 ... testN}}
 * @param  {mixed} value Value to check against
 * @param  {mixed} ...test Values to test
 * @return {mixed} Matched value
 *
 * @signature {{#is value test1 ... testN}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/is}}
 * @describe Truthy block will evaluate with the result value as the current context ({this}).
 */

function is (...args) {
	if (args.length < 3) throw new Error('Helper "is" needs a minimum of 2 arguments');
	const { fn, inverse } = args.pop();
	const value = args.shift();
	const result = args.includes(value);
	if (!fn) return result || '';
	return result ? fn(this) : inverse && inverse(this);
}

/**
 * Tests that the first argument does not match any of the other arguments with strict equality.
 * @category logic,default
 *
 * @signature {{isNot value test1 ... testN}}
 * @param  {mixed} value Value to check against
 * @param  {mixed} ...test Values to test
 * @return {mixed} Matched value
 *
 * @signature {{#isNot value test1 ... testN}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/isNot}}
 */

function isNot (...args) {
	if (args.length < 3) {
		throw new Error('Helper "isNot" needs a minimum of 2 arguments');
	}

	const { fn, inverse } = args.pop();
	const value = args.shift();

	var result = args.indexOf(value) === -1;

	if (!fn) return result || '';

	return result ? fn() : inverse && inverse();
}

/**
 * Sends the passed arguments to console.log
 * @name log
 * @category debug
 *
 * @signature {{log}}
 * @return {null} Sends the current context to console.log
 *
 * @signature {{log argument1 ... argumentN}}
 * @param  {...mixed} args Arguments to send to console.log
 * @return {null}
 */
function log (...args) {
	const { env } = args.pop();
	if (!args.length) args = [ env ];
	console.log(...args); // eslint-disable-line no-console
}
/***/

/**
 * Evaluates the block contents of the passed input is falsey or equals a target.
 *
 * @category logic,default
 *
 * @signature {{#not input [target]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/not}}
 * @example
 * @param  {mixed} input Value to test.
 * @param  {mixed} target Value to test against (strict equality). If omitted, helper will check if `input` is falsey.
 * // name = { first: 'John', last: 'Doe' }
 * {{#not name}}No Name Defined{{else}}<span>{{first}} {{last}}</span>{{/not}}
 * // Result: <span>John Doe</span>
 */
function not (...args) {
	const { ctx, fn, inverse } = args.pop();
	const value = args.shift();
	const result = args.length ? value !== args[0] : falsey(value);
	if (!fn) return result || '';
	return result ? fn(ctx) : inverse && inverse();
}

const helpers = {
	if:     _if,
	with:   _with,
	each,
	log,
	not,
	unless: not,
	has: has$1,
	is,
	isNot,
	all: all$1,
	any,
	get: get$1,
	lookup: get$1,
};

function parse (input) {
	if (isString(input)) return lex(input);
	if ((input instanceof Block)) return input;
	wtf('Parse can only receive strings or a Handybars AST tree');
}

function evaluate (input, ctx) {
	if (isString(input)) input = lex(input);
	else if (!(input instanceof Block)) {
		wtf('Evaluate can only receive strings or a Handybars AST tree');
	}

	return input.evaluate(ctx, helpers).value;
}

function Handybars (template, world = {}) {
	const ast = parse(template);
	const env = { ...helpers, ...world };

	function execute (ctx) {
		const frame = makeContext(ctx, env);
		return ast.evaluate(ctx, frame).value;
	}

	execute.set = (...args) => {
		if (isObject(args[0])) {
			Object.assign(env, ...args);
		} else {
			set(env, ...args);
		}
		return execute;
	};

	execute.setPartial = (name, subtemplate) => set(env, name, lex(subtemplate));

	return execute;
}

export default Handybars;
export { Block, Collection, CompoundIdentifier, Identifier, Invocation, Literal, Text, evaluate, makeContext, parse, parse as partial, safe, safeJoin };
