/**
 * 
 * Handybars
 * 
 * Copyright (c) 2020, Jocelyn Badgley
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Portions of the MIT licensed date-fns library are bundled with this
 * software. https://github.com/date-fns/date-fns#readme
 */

(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?f(exports):typeof define==='function'&&define.amd?define(['exports'],f):(g=g||self,f(g.MiniHandle={}));}(this,(function(exports){'use strict';function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}var MISSING = '{!MISSING!}'; // htmlEscape copied from Sindre Sorhus' escape-goat

var htmlEscape = function htmlEscape(input) {
  return input.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
};
function makeContext(ctx, env) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$hash = _ref.hash,
      hash = _ref$hash === void 0 ? null : _ref$hash;

  var frame = env ? Object.create(env) : {};
  if (hash) Object.assign(frame, hash);
  frame.this = ctx;
  frame['@env'] = frame;
  frame['@value'] = ctx;
  frame['@parent'] = env;
  frame['@root'] = env['@root'] || frame;
  return frame;
}
function contextIterate(input, env, fn, hash) {
  var frame = makeContext(input, env, {
    hash: hash
  });
  var c = sizeOf(input);
  return safeJoin(input, function (value, key, index) {
    frame.this = value;
    frame['@value'] = value;
    frame['@key'] = key;
    frame['@index'] = index;
    frame['@first'] = index === 0;
    frame['@last'] = index === c - 1;
    return fn(value, frame);
  });
}
var SAFE_NONE = 0;
var SAFE_WRAPPED = 1;
var SAFE_ESCAPED = 2;
function safe(input) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SAFE_WRAPPED;

  if (isUndefinedOrNull(input) || isFalse(input)) {
    if (level === SAFE_NONE) return input;
    return {
      value: '',
      safety: level
    };
  }

  if (isString(input)) {
    if (level === SAFE_NONE) return input;
    if (level === SAFE_WRAPPED) return {
      value: input,
      safety: level
    };
    if (level === SAFE_ESCAPED) return {
      value: input && htmlEscape(input)
    };
  }

  if (isObject(input) && hasOwn(input, 'value')) {
    if (level === SAFE_NONE) return input.value;
    return {
      value: input.value,
      safety: level
    };
  }

  if (level === SAFE_NONE) return input;
  return {
    value: input,
    safety: level
  };
}
safe.NONE = SAFE_ESCAPED;
safe.WRAPPED = SAFE_WRAPPED;
safe.ESCAPED = SAFE_ESCAPED;

safe.down = function (input) {
  return safe(input, SAFE_NONE);
};

safe.up = function (input) {
  return safe(input, SAFE_ESCAPED);
};

function safeJoin(inputs, predicate) {
  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  predicate = iteratee(predicate);
  return {
    value: map(inputs, function (val, k, i) {
      return safe.up(predicate(val, k, i)).value;
    }).join(delimiter)
  };
}
function wtf(msg, info) {
  if (info) console.error(info); // eslint-disable-line no-console

  throw new Error(msg);
}
function equals(value) {
  value = uc(value);
  return function (tok) {
    return uc(tok) === value;
  };
}
function anyOf() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  args = args.flat().map(uc);

  if (!anyBy(args, isFunction)) {
    // arguments do not contain a function, so we can optimize
    if (args.length === 1) return function (tok) {
      return uc(tok) === args[0];
    };
    return function (tok) {
      return args.includes(uc(tok));
    };
  }

  args = args.map(function (a) {
    return isFunction(a) && a || equals(a);
  });
  if (args.length === 1) return function (tok) {
    return args[0](tok);
  };
  return function (tok) {
    return anyBy(args, function (check) {
      return check(tok);
    });
  };
}
function isNumber(input) {
  return typeof input === 'number' && !isNaN(input);
}
function isString(input) {
  return typeof input === 'string';
}
function isFunction(input) {
  return typeof input === 'function';
}
function isNull(input) {
  return input === null;
}
function isUndefined(input) {
  return typeof input === 'undefined';
}
function isUndefinedOrNull(input) {
  return isUndefined(input) || isNull(input);
}
function isNotUndefinedOrNull(input) {
  return !isUndefined(input) && !isNull(input);
}
function isMap(input) {
  return input instanceof Map;
}
function isSet(input) {
  return input instanceof Set;
}
function isFalse(input) {
  return input === false;
}
var isArray = Array.isArray;
function isPrimitive(input) {
  switch (_typeof(input)) {
    case 'string':
    case 'number':
    case 'boolean':
      return true;

    default:
      return false;
  }
}
function isObject(input) {
  if (!input) return false;
  if (_typeof(input) !== 'object') return false;
  if (isArray(input)) return false;
  if (!(input instanceof Object)) return false;
  if (input.constructor !== Object.prototype.constructor) return false;
  return true;
}
function truthy(value) {
  if (isMappable(value)) return !!sizeOf(value);
  return !!value;
}
function falsey(value) {
  return !truthy(value);
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function uc(str) {
  return isString(str) ? str.toUpperCase() : str;
}
function get(obj, path, defaultValue) {
  if (isUndefinedOrNull(obj) || isPrimitive(obj)) throw new TypeError('Input object was not a collection.');
  if (isUndefinedOrNull(path) || path === '') return false;
  if (isNumber(path)) path = [String(path)];else if (isString(path)) {
    if (hasOwn(obj, path)) return obj[path];
    path = path.split(/[,[\].]+?/);
  }
  var result = path.filter(function (s) {
    return isNotUndefinedOrNull(s) && s !== '';
  }).reduce(function (res, key) {
    return isNotUndefinedOrNull(res) ? res[key] : res;
  }, obj);
  return isUndefined(result) || result === obj ? defaultValue : result;
}
function has(obj, path) {
  if (isUndefinedOrNull(path) || path === '') return false;
  if (isNumber(path)) path = [String(path)];else if (isString(path)) path = String.prototype.split.call(path, /[,[\].]+?/);
  var res = obj;

  var _iterator2 = _createForOfIteratorHelper(path),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var key = _step2.value;
      if (isUndefinedOrNull(res) || _typeof(res) !== 'object' && isFunction(res) || isUndefined(res[key])) return false;
      res = res[key];
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return true;
}
function set(obj, path, value) {
  if (isUndefinedOrNull(path) || path === '') return false;
  if (isNumber(path)) path = [String(path)];else if (isString(path)) {
    if (hasOwn(obj, path)) {
      obj[path] = value;
      return obj;
    }

    path = path.split(/[,[\].]+?/);
  }
  var c = path.length - 1;
  path.filter(function (s) {
    return s || s === 0;
  }).reduce(function (res, key, i) {
    if (i === c) {
      res[key] = value;
      return true;
    }

    if (isObject(res[key]) || isFunction(res[key])) return res[key];
    return res[key] = {};
  }, obj);
  return obj;
}
function isMappable(collection) {
  var arrays = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return arrays && isArray(collection) || arrays && isSet(collection) || isMap(collection) || collection && (_typeof(collection) === 'object' || typeof collection === 'function');
}
function sizeOf(collection) {
  if (isArray(collection) || isString(collection)) return collection.length;
  if (isSet(collection) || isMap(collection)) return collection.size;
  if (isObject(collection)) return Object.keys(collection).length;
  return !!collection;
}
function arrayify(input) {
  if (isArray(input)) return input;
  if (isSet(input) || isMap(input)) return Array.from(input.values());
  if (isObject(input)) return Object.values(input);
  if (isString(input)) return input.split(/,\s*/);
  return [input];
}
function all() {
  var input;

  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  if (args.length > 1) {
    input = args;
  } else {
    input = arrayify(args[0]);
  }

  var result = input.shift();

  var _iterator5 = _createForOfIteratorHelper(input),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var value = _step5.value;

      if (!truthy(result)) {
        return false;
      }

      result = value;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return result;
}
function anyBy(collection) {
  var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!collection) return false;

  if (predicate === null) {
    predicate = function predicate(v) {
      return v;
    };
  } else if (!isFunction(iteratee)) {
    predicate = iteratee(predicate);
  }

  if (isArray(collection)) {
    var i = 0;

    var _iterator10 = _createForOfIteratorHelper(collection),
        _step10;

    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var value = _step10.value;
        if (predicate(value, i, i++)) return true;
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }

    return false;
  }

  if (isSet(collection)) {
    var _i7 = 0;

    var _iterator11 = _createForOfIteratorHelper(collection),
        _step11;

    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var item = _step11.value;
        if (predicate(item, _i7, _i7++)) return true;
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }

    return false;
  } // received a Map


  if (isMap(collection)) {
    var _i8 = 0;

    var _iterator12 = _createForOfIteratorHelper(collection.entries()),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var _step12$value = _slicedToArray(_step12.value, 2),
            key = _step12$value[0],
            _value3 = _step12$value[1];

        if (predicate(_value3, key, _i8++)) return true;
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    return false;
  } // received an object hash


  if (isObject(collection)) {
    var _i9 = 0;

    for (var _i10 = 0, _Object$entries3 = Object.entries(collection); _i10 < _Object$entries3.length; _i10++) {
      var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i10], 2),
          _key12 = _Object$entries3$_i[0],
          _value4 = _Object$entries3$_i[1];

      if (predicate(_value4, _key12, _i9++)) return true;
    }

    return false;
  }

  return !!collection;
}
function iteratee(match) {
  if (isUndefinedOrNull(match)) return function (v) {
    return v;
  };
  if (isFunction(match)) return match;

  if (isString(match)) {
    return function (o) {
      if (isArray(o)) return o.includes(match);
      if (isObject(o)) return o[match];
      if (isMap(o)) return o.get(match);
      if (isSet(o)) return o.has(match);
      if (isPrimitive(o)) return o[match];
      return o === match;
    };
  }

  if (isNumber(match)) {
    return function (o) {
      if (isObject(o) || isArray(o)) return o[match];
      if (isMap(o)) return o.get(match);
      if (isSet(o)) return o.has(match);
      if (isNumber(o)) return o === match;
      if (isString(o)) return Number(o) === match;
      return o === match;
    };
  }

  if (isArray(match)) {
    var _match = _slicedToArray(match, 2),
        key = _match[0],
        value = _match[1];

    return function (o) {
      return o[key] === value;
    };
  }

  if (isObject(match)) {
    // create an array of key/value iteratees
    var tests = Object.entries(match).map(iteratee); // evaluate the object against the array

    return function (o) {
      var _iterator13 = _createForOfIteratorHelper(tests),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var t = _step13.value;
          if (!t(o)) return false;
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }

      return true;
    };
  }
}
function toPairs(object) {
  return Object.entries(object);
}
function fromPairs(entries) {
  return mapReduce(entries, function (_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
        v = _ref5[0],
        k = _ref5[1];

    return [v, k];
  });
}
function slice(collection, begin, end) {
  if (isString(collection) || isArray(collection)) return collection.slice(begin, end);

  if (isSet(collection)) {
    return new Set(Array.from(collection.values()).slice(begin, end));
  }

  if (isMap(collection)) {
    return new Map(Array.from(collection.entries()).slice(begin, end));
  }

  if (isObject(collection)) {
    return fromPairs(toPairs(collection).slice(begin, end));
  }

  return collection;
}
function map(collection, predicate) {
  predicate = iteratee(predicate);

  if (isArray(collection)) {
    return collection.map(function (value, i) {
      return predicate(value, i, i);
    });
  } else if (isSet(collection)) {
    return Array.from(collection, function (value, i) {
      return predicate(value, i, i);
    });
  } else if (isMap(collection)) {
    return Array.from(collection.entries(), function (_ref6, index) {
      var _ref7 = _slicedToArray(_ref6, 2),
          key = _ref7[0],
          value = _ref7[1];

      return predicate(value, key, index);
    });
  } else if (isObject(collection)) {
    return Object.entries(collection).map(function (_ref8, index) {
      var _ref9 = _slicedToArray(_ref8, 2),
          key = _ref9[0],
          value = _ref9[1];

      return predicate(value, key, index);
    });
  } else if (isString(collection)) {
    return collection.split().map(function (value, i) {
      return predicate(value, i, i);
    });
  }

  return [];
}
function makeIterate(predicate) {
  var tuple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  predicate = iteratee(predicate);
  var result = {};

  function iterate(val, k, i) {
    // return true to continue looping
    var res = predicate(val, k, i) || [];

    if (tuple) {
      if (res === false) return false;
      if (!res || !isArray(res)) return true;

      var _res = _slicedToArray(res, 2),
          key = _res[0],
          value = _res[1];

      if (isUndefinedOrNull(key) || isUndefined(value)) return true;
      result[key] = value;
    } else {
      result[k] = res;
    }

    return true;
  }

  iterate.result = function () {
    return result;
  };

  return iterate;
}
function mapValues(collection, predicate) {
  if (!isObject(collection)) throw new Error('mapValues only works for simple objects, use mapReduce.');
  var iterate = makeIterate(predicate);
  var i = 0;

  for (var _i22 = 0, _Object$entries9 = Object.entries(collection); _i22 < _Object$entries9.length; _i22++) {
    var _Object$entries9$_i = _slicedToArray(_Object$entries9[_i22], 2),
        key = _Object$entries9$_i[0],
        value = _Object$entries9$_i[1];

    if (!iterate(value, key, i++)) break;
  }

  return iterate.result();
}
/**
 * Iterates over a collection and generates an object based on tuple returned from the iteratee.
 * @param  {Object|Array|Map|Set} collection
 * @param  {Function} iteratee Callback invoked for each item, receives `value, key, index`, returns `[key, value]`;
 * @return {Object}
 */

function mapReduce(collection, predicate) {
  if (!collection) return {};
  var iterate = makeIterate(predicate, true);

  if (isArray(collection)) {
    var i = 0;

    var _iterator21 = _createForOfIteratorHelper(collection),
        _step21;

    try {
      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
        var value = _step21.value;
        if (!iterate(value, i, i++)) break;
      }
    } catch (err) {
      _iterator21.e(err);
    } finally {
      _iterator21.f();
    }
  } else if (isSet(collection)) {
    var _i23 = 0;

    var _iterator22 = _createForOfIteratorHelper(collection),
        _step22;

    try {
      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
        var item = _step22.value;
        if (!iterate(item, _i23, _i23++)) break;
      }
    } catch (err) {
      _iterator22.e(err);
    } finally {
      _iterator22.f();
    }
  } else if (isMap(collection)) {
    var _i24 = 0;

    var _iterator23 = _createForOfIteratorHelper(collection.entries()),
        _step23;

    try {
      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
        var _step23$value = _slicedToArray(_step23.value, 2),
            key = _step23$value[0],
            _value11 = _step23$value[1];

        if (!iterate(_value11, key, _i24++)) break;
      }
    } catch (err) {
      _iterator23.e(err);
    } finally {
      _iterator23.f();
    }
  } else if (isObject(collection)) {
    var _i25 = 0;

    for (var _i26 = 0, _Object$entries10 = Object.entries(collection); _i26 < _Object$entries10.length; _i26++) {
      var _Object$entries10$_i = _slicedToArray(_Object$entries10[_i26], 2),
          _key15 = _Object$entries10$_i[0],
          _value12 = _Object$entries10$_i[1];

      if (!iterate(_value12, _key15, _i25++)) break;
    }
  }

  return iterate.result();
}
function reduce(collection, predicate, init) {
  if (!isFunction(predicate)) throw new TypeError('Predicate must be a function');
  if (isArray(collection)) return collection.reduce(function (r, v, i) {
    return predicate(r, v, i, i);
  }, init);

  if (isSet(collection)) {
    return Array.from(collection).reduce(function (r, v, i) {
      return predicate(r, v, i, i);
    }, init);
  }

  if (isMap(collection)) {
    return Array.from(collection.entries()).reduce(function (prev, _ref16, i) {
      var _ref17 = _slicedToArray(_ref16, 2),
          key = _ref17[0],
          value = _ref17[1];

      return predicate(prev, value, key, i);
    }, init);
  }

  if (isObject(collection)) {
    return Object.entries(collection).reduce(function (prev, _ref18, i) {
      var _ref19 = _slicedToArray(_ref18, 2),
          key = _ref19[0],
          value = _ref19[1];

      return predicate(prev, value, key, i);
    }, init);
  }
}
function flatten(collection) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  if (depth <= 0) return slice(collection);
  return reduce(collection, function (acc, val) {
    return acc.concat.apply(acc, _toConsumableArray(isMappable(val) ? flatten(val, depth - 1) : [val]));
  }, []);
}var T_WHITESPACE = 0;
var T_TEXT = 1;
var T_BLOCK_OPEN = 2;
var T_BLOCK_STOP = 3;
var T_BLOCK_START = 4;
var T_BLOCK_CLOSE = 5;
var T_ELSE = 6;
var T_IDENTIFIER = 7;
var T_LITERAL_NUM = 8;
var T_LITERAL_STR = 9;
var T_LITERAL_PRI = 10;
var T_BRACKET_OPEN = 11;
var T_BRACKET_CLOSE = 12;
var T_PAREN_OPEN = 13;
var T_PAREN_CLOSE = 14;
var T_ASSIGNMENT = 15;
var T = ['WHITESPACE', 'TEXT', 'BLOCK_OPEN', 'BLOCK_STOP', 'BLOCK_START', 'BLOCK_CLOSE', 'ELSE', 'IDENTIFIER', 'LITERAL_NUM', 'LITERAL_STR', 'LITERAL_PRI', 'BRACKET_OPEN', 'BRACKET_CLOSE', 'PAREN_OPEN', 'PAREN_CLOSE', 'ASSIGNMENT'];
var LF = 10;
var CR = 13;
var SPACE = 32;
var NBSP = 160;
var CURL_OPEN = 123; // {

var CURL_CLOSE = 125; // }

var BRACKET_OPEN = 91; // [

var BRACKET_CLOSE = 93; // ]

var PAREN_OPEN = 40; // (

var PAREN_CLOSE = 41; // )

var HASH = 35; // #

var SLASH = 47; // /

var BACKSLASH = 92; // \

var DOLLAR = 36; // $

var EQUAL = 61; // =

var AT = 64; // @

var UNDERSCORE = 95; // _

var PERIOD = 46; // .

var MINUS = 45; // -

var QUOT = 39; // '

var DOUBLEQUOT = 34; // "

var isAlpha = function isAlpha(char) {
  return char >= 65 && char <= 90 || char >= 97 && char <= 122;
};

var isNumeric = function isNumeric(char) {
  return char >= 48 && char <= 57;
};

var isIdent = anyOf(isAlpha, isNumeric, UNDERSCORE, AT, DOLLAR, PERIOD);

var isMinusPeriod = function isMinusPeriod(char) {
  return char === MINUS || char === PERIOD;
};

var isQuot = function isQuot(char) {
  return char === QUOT || char === DOUBLEQUOT;
};

function tokenizer(input) {
  var max = input.length - 1;
  var inside = false;
  var pos = 0;
  var line = 1;
  var col = 1;
  var tokens = [];
  var tindex = -1;

  function token(type) {
    var contents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : line;
    var c = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : col;
    var tok = {
      type: type,
      contents: contents,
      line: l,
      column: c
    };
    tokens.push(tok);
    return tok;
  }

  var err = new SyntaxError();

  function wtf(msg) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$l = _ref.l,
        l = _ref$l === void 0 ? line : _ref$l,
        _ref$c = _ref.c,
        c = _ref$c === void 0 ? col : _ref$c,
        extra = _objectWithoutProperties(_ref, ["l", "c"]);

    err.message = msg + " (".concat(l, ":").concat(c, ")");
    console.dir(tokens); // eslint-disable-line no-console

    throw Object.assign(err, extra, {
      line: l,
      column: c
    });
  }

  function plc() {
    return {
      p: pos,
      l: line,
      c: col
    };
  }

  function matchWord(value) {
    return input.startsWith(value, pos);
  }

  function peek() {
    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var i = pos + delta;
    if (i > max || i < 0) return;
    return input.charCodeAt(i);
  }

  function parseChar(char) {
    if (char === CR || char === LF) {
      line++;
      col = 1; // account for CRLF

      if (char === CR && input.charCodeAt(pos) === LF) {
        pos++;
      }
    } else {
      col++;
    }
  }

  function move() {
    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var index = Math.min(max + 1, Math.max(0, pos + delta));
    if (delta > 0) for (var i = pos; i < index; i++) {
      parseChar(input.charCodeAt(i));
    }
    pos = index;
    return pos <= max;
  }

  function eof() {
    return pos > max;
  }

  function readRaw() {
    if (inside) return;
    var char = peek();

    var _plc = plc(),
        p = _plc.p,
        l = _plc.l,
        c = _plc.c;

    do {
      if (char === CURL_OPEN && peek(1) === CURL_OPEN) break;
      move();
    } while (char = peek());

    if (p === pos) return;
    token(T_TEXT, input.slice(p, pos), l, c);
    return true;
  }

  function readBlockStart() {
    if (inside || peek(0) !== CURL_OPEN || peek(1) !== CURL_OPEN) return;
    inside = true;
    var tok = token(T_BLOCK_START, '{{');

    if (peek(2) === CURL_OPEN) {
      tok.raw = true;
      tok.contents = '{{{';
      move(3);
    } else move(2);

    if (peek() === HASH) {
      token(T_BLOCK_OPEN, '#');
      move(1);
    } else if (peek() === SLASH) {
      token(T_BLOCK_CLOSE, '/');
      move(1);
    } else if (matchWord('else') || matchWord('ELSE')) {
      token(T_ELSE, 'else');
      move(4);
    }

    return true;
  }

  function readBlockEnd() {
    if (!inside || peek(0) !== CURL_CLOSE || peek(1) !== CURL_CLOSE) return;
    inside = false;
    var tok = token(T_BLOCK_STOP, '}}');

    if (peek(2) === CURL_CLOSE) {
      tok.raw = true;
      tok.contents = '}}}';
      move(3);
    } else move(2);

    return true;
  }

  function readWhitespace() {
    if (!inside) return;

    var _plc2 = plc(),
        p = _plc2.p,
        l = _plc2.l,
        c = _plc2.c;

    var char;

    while (pos <= max && (char = peek(0))) {
      if (char > 14 && char !== SPACE && char !== NBSP) break;
      move();
    }

    if (p === pos) return;
    token(T_WHITESPACE, input.slice(p, pos), l, c);
    return true;
  }

  function readParenStart() {
    if (!inside || peek() !== PAREN_OPEN) return;
    token(T_PAREN_OPEN, '(');
    move();
    return true;
  }

  function readParenEnd() {
    if (!inside || peek() !== PAREN_CLOSE) return;
    token(T_PAREN_CLOSE, ')');
    move(); // If the paren is followed by a period, then we are accessing something off the result

    if (peek() === PERIOD) move();
    return true;
  }

  function readBrackStart() {
    if (!inside || peek() !== BRACKET_OPEN) return;
    token(T_BRACKET_OPEN, '[');
    move();
    return true;
  }

  function readBrackEnd() {
    if (!inside || peek() !== BRACKET_CLOSE) return;
    token(T_BRACKET_CLOSE, ']');
    move();
    if (peek() === PERIOD) move();
    return true;
  }

  function readAssignment() {
    if (!inside || peek() !== EQUAL) return;
    token(T_ASSIGNMENT, '=');
    move();
    return true;
  }

  function readIdentifier() {
    var char = peek();
    if (!inside || isNumeric(char) || !isIdent(char) || char === PERIOD) return;

    var _plc3 = plc(),
        p = _plc3.p,
        l = _plc3.l,
        c = _plc3.c;

    move();

    while (char = peek()) {
      if (!isIdent(char)) break;
      move();
    }

    if (p === pos) return;
    var contents = input.slice(p, pos);
    if (contents === 'true') token(T_LITERAL_PRI, true, l, c);else if (contents === 'false') token(T_LITERAL_PRI, false, l, c);else if (contents === 'null') token(T_LITERAL_PRI, null, l, c);else token(T_IDENTIFIER, contents, l, c);
    return true;
  }

  function readNumber() {
    if (!inside) return;
    var char = peek();
    if (!isNumeric(char) && !isMinusPeriod(char)) return;
    if (isMinusPeriod(char) && !isNumeric(peek(1))) return;

    var _plc4 = plc(),
        p = _plc4.p,
        l = _plc4.l,
        c = _plc4.c;

    var hasPeriod = false;

    do {
      if (char === MINUS) {
        if (pos !== p) break;
        move();
        continue;
      } // found a minus after the start of the number, this is not part of the token.


      if (char === PERIOD) {
        if (hasPeriod) break; // we found an extra period, not part of the token.

        hasPeriod = true;
      } else if (!isNumeric(char)) break; // found something that was neither number nor period, not part of the token.


      move();
    } while (char = peek());

    if (p === pos) return;
    token(T_LITERAL_NUM, input.slice(p, pos), l, c);
    return true;
  }

  function readString() {
    var char = peek();
    if (!inside || !isQuot(char)) return;

    var _plc5 = plc(),
        p = _plc5.p,
        l = _plc5.l,
        c = _plc5.c;

    var fence = char;
    move();

    while (char = peek()) {
      if (char === BACKSLASH) {
        move(2);
        continue;
      }

      if (char === fence) {
        token(T_LITERAL_STR, pos - p === 1 ? '' : input.slice(p + 1, pos).replace(/\\(.)/, '$1'), l, c);
        move();
        return true;
      }

      move();
    }

    wtf("Unterminated string literal: ".concat(input.substr(p, 20), "\u2026"), {
      l: l,
      c: c
    });
  }

  function read() {
    if (eof()) return false;

    var _iterator = _createForOfIteratorHelper(read.order),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var r = _step.value;
        // console.log(r, pos);
        if (r()) return true;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    wtf("Unknown token: ".concat(input.substr(pos, 20), "\u2026"));
  }

  read.order = [readBlockStart, readRaw, readWhitespace, readIdentifier, readNumber, readString, readAssignment, readBrackStart, readBrackEnd, readParenStart, readParenEnd, readBlockEnd];
  return {
    get eof() {
      return eof();
    },

    get current() {
      while (tindex >= tokens.length && !eof()) {
        read();
      }

      return tokens[tindex];
    },

    readAll: function readAll() {
      while (read()) {
      }

      return tokens;
    },
    reset: function reset() {
      tindex = -1;
      return this;
    },
    next: function next() {
      tindex++;

      while (tindex >= tokens.length && !eof()) {
        read();
      }

      return tokens[tindex];
    },
    peek: function peek() {
      var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var idx = tindex + delta;

      while (idx >= tokens.length && !eof()) {
        read();
      }

      return tokens[idx];
    }
  };
}var Node = /*#__PURE__*/function () {
  function Node() {
    _classCallCheck(this, Node);

    this._type = 'Node';
  }

  _createClass(Node, [{
    key: "evaluate",
    value: function evaluate() {
      return null;
    }
  }]);

  return Node;
}();
var Text = /*#__PURE__*/function (_Node) {
  _inherits(Text, _Node);

  var _super = _createSuper(Text);

  function Text() {
    var _this;

    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    _classCallCheck(this, Text);

    _this = _super.call(this);
    _this.value = value;
    _this._type = 'Text';
    return _this;
  }

  _createClass(Text, [{
    key: "evaluate",
    value: function evaluate() {
      return {
        value: this.value
      };
    }
  }]);

  return Text;
}(Node);
var Block = /*#__PURE__*/function (_Node2) {
  _inherits(Block, _Node2);

  var _super2 = _createSuper(Block);

  function Block(_ref) {
    var _this2;

    var type = _ref.type,
        invoker = _ref.invoker,
        left = _ref.left,
        right = _ref.right,
        raw = _ref.raw,
        props = _objectWithoutProperties(_ref, ["type", "invoker", "left", "right", "raw"]);

    _classCallCheck(this, Block);

    _this2 = _super2.call(this);
    Object.assign(_assertThisInitialized(_this2), props);
    _this2.type = type;
    _this2.invoker = invoker || null;
    _this2.left = left || null;
    _this2.right = right || null;
    _this2.raw = raw || false;
    _this2._type = 'Block';
    return _this2;
  }

  _createClass(Block, [{
    key: "_descender",
    value: function _descender(tree, ctx, env) {
      if (!tree || !tree.length) return null;
      return function () {
        var subctx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ctx;
        var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : env;
        if (e === env && subctx !== ctx) e = makeContext(subctx, e);
        return render(tree, subctx, e);
      };
    }
  }, {
    key: "evaluate",
    value: function evaluate(ctx) {
      var env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var fn = this._descender(this.left, ctx, env);

      var inverse = this._descender(this.right, ctx, env);

      var children = this.left && this.left.length ? this.left : null;
      var result = this.invoker ? this.invoker.evaluate(ctx, env, {
        fn: fn,
        inverse: inverse,
        children: children
      }) : fn && fn(ctx) || undefined;
      return this.raw ? safe(result) : safe.up(result);
    }
  }]);

  return Block;
}(Node);
var Invocation = /*#__PURE__*/function (_Node3) {
  _inherits(Invocation, _Node3);

  var _super3 = _createSuper(Invocation);

  function Invocation() {
    var _this3;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Invocation);

    _this3 = _super3.call(this);
    Object.assign(_assertThisInitialized(_this3), props);
    _this3.arguments = props.arguments || [];
    _this3.hash = props.hash || {};
    _this3._type = 'Invocation';
    return _this3;
  }

  _createClass(Invocation, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          fn = _ref2.fn,
          inverse = _ref2.inverse,
          children = _ref2.children;

      if (!this.arguments.length) return ''; // this shouldn't happen

      var _this$arguments = _toArray(this.arguments),
          target = _this$arguments[0],
          args = _this$arguments.slice(1);

      target = target.evaluate(ctx, env);
      var hash = this.hashCount ? mapValues(this.hash, function (a) {
        return safe.down(a.evaluate(ctx, env));
      }) : {};

      if (target && isFunction(target.evaluate)) {
        var source = args.length ? args[0] : ctx;
        var frame = makeContext(source, env, {
          hash: hash
        });
        if (children) frame['@partial-block'] = new Block({
          type: '@partial-block',
          left: children
        });
        return target.evaluate(source, frame);
      }

      if (!isFunction(target)) {
        if (target && fn) return fn(ctx, env);
        if (!target && inverse) return inverse(ctx, env);
        if (fn && inverse) return target ? fn(ctx, env) : inverse(ctx, env);
        return target;
      }

      args = args.map(function (a) {
        return safe.down(a.evaluate(ctx, env));
      });
      return target.apply(void 0, _toConsumableArray(args).concat([{
        ctx: ctx,
        env: env,
        fn: fn,
        inverse: inverse,
        arguments: args,
        hash: hash,
        resolve: function resolve(what) {
          return _resolve(what, ctx, env);
        }
      }]));
    }
  }, {
    key: "set",
    value: function set(key, value) {
      this.hash[key] = value;
      this.hashCount = (this.hashCount || 0) + 1;
      return this;
    }
  }]);

  return Invocation;
}(Node);
var Collection = /*#__PURE__*/function (_Invocation) {
  _inherits(Collection, _Invocation);

  var _super4 = _createSuper(Collection);

  function Collection(args) {
    var _this4;

    _classCallCheck(this, Collection);

    _this4 = _super4.call(this);
    _this4.arguments = args || [];
    _this4._type = 'Collection';
    return _this4;
  }

  _createClass(Collection, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.arguments.map(function (a) {
        return a.evaluate(ctx, env);
      });
    }
  }]);

  return Collection;
}(Invocation);
var Identifier = /*#__PURE__*/function (_Node4) {
  _inherits(Identifier, _Node4);

  var _super5 = _createSuper(Identifier);

  function Identifier(target, critical) {
    var _this5;

    _classCallCheck(this, Identifier);

    _this5 = _super5.call(this);
    _this5.target = target;
    _this5.critical = !!critical;
    _this5._type = 'Identifier';
    return _this5;
  }

  _createClass(Identifier, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _resolve(this.target, ctx, env, this.critical);
    }
  }]);

  return Identifier;
}(Node);
var CompoundIdentifier = /*#__PURE__*/function (_Node5) {
  _inherits(CompoundIdentifier, _Node5);

  var _super6 = _createSuper(CompoundIdentifier);

  function CompoundIdentifier(target) {
    var _this6;

    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var critical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    _classCallCheck(this, CompoundIdentifier);

    _this6 = _super6.call(this);
    _this6.path = target.split(/[,[\].]+?/).filter(Boolean).map(function (i) {
      return new Identifier(i);
    });
    _this6.refs = [];
    _this6.critical = critical;
    _this6._type = 'CompoundIdentifier';

    var _iterator = _createForOfIteratorHelper(args),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var arg = _step.value;
        if (arg.r) _this6.pushRef(arg.r);else _this6.pushTarget(arg);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return _this6;
  }

  _createClass(CompoundIdentifier, [{
    key: "evaluate",
    value: function evaluate(ctx) {
      var _this7 = this;

      var env = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var refs = this.refs.map(function (spec) {
        return safe.down(spec.evaluate(ctx, env, _this7.critical));
      });
      var path = this.path.map(function (spec) {
        if (spec.ref !== undefined) {
          spec = refs[spec.ref];
        }

        if (spec.evaluate) {
          return safe.down(spec.evaluate(ctx, env, _this7.critical));
        }

        return spec;
      });
      var target = path.shift();
      if (!target) return;
      var result = get(target, path, MISSING);
      return result === MISSING ? undefined : result;
    }
  }, {
    key: "pushRef",
    value: function pushRef(spec) {
      this.refs.push(spec);
      this.path.push({
        ref: this.refs.length - 1
      });
    }
  }, {
    key: "pushTarget",
    value: function pushTarget(spec) {
      this.path.push(spec);
    }
  }]);

  return CompoundIdentifier;
}(Node);
var Literal = /*#__PURE__*/function (_Node6) {
  _inherits(Literal, _Node6);

  var _super7 = _createSuper(Literal);

  function Literal(value) {
    var _this8;

    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : T_LITERAL_PRI;

    _classCallCheck(this, Literal);

    _this8 = _super7.call(this);
    _this8.value = value;
    _this8.type = type;
    _this8._type = 'Literal';
    return _this8;
  }

  _createClass(Literal, [{
    key: "evaluate",
    value: function evaluate() {
      if (this.type === T_LITERAL_NUM) return parseFloat(this.value);
      return this.value;
    }
  }]);

  return Literal;
}(Node);

function render(children, ctx, env) {
  if (!Array.isArray(children) || !children.length) return '';
  var value = children.map(function (c) {
    return safe.up(c.evaluate(ctx, env));
  }).filter(function (c) {
    return c.value !== '';
  }).map(function (c) {
    return c.value;
  }).join('');
  return {
    value: value
  };
}

function _resolve(what, ctx, env) {
  var needed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var target;
  if (!isUndefinedOrNull(ctx) && !isPrimitive(ctx) && (target = get(ctx, what, MISSING)) !== MISSING) return target;
  if (!isUndefinedOrNull(env) && (target = get(env, what, MISSING)) !== MISSING) return target;
  var parent = env;

  while (parent = parent['@parent']) {
    if (!isUndefinedOrNull(parent.this) && !isPrimitive(parent.this) && (target = get(parent.this, what, MISSING)) !== MISSING) return target;
    if (!isUndefinedOrNull(parent) && (target = get(parent, what, MISSING)) !== MISSING) return target;
  }

  if (needed) wtf("Could not resolve \"".concat(what, "\""));
  return;
}function lex(input, debug) {
  var tokens = tokenizer(input);
  var tok, contents;
  var tindex = 0;

  function next(type, required) {
    if (tokens.eof) return;
    var t = tokens.peek();

    if (!isUndefined(type) && t && t.type !== type) {
      if (required) wtf(isString(required) ? required : "Expected ".concat(type, " but found ").concat(T[t.type]), t);
      return;
    }

    contents = t.contents;
    tindex++;
    return tok = tokens.next();
  }

  function peek(type) {
    var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var t = tokens.peek(delta);
    if (!isUndefined(type) && t && t.type !== type) return;
    return t;
  }

  var err = new SyntaxError();

  function wtf() {
    var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Unexpected token: ' + T[tok.type];

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tok || {},
        line = _ref.line,
        column = _ref.column,
        extra = _objectWithoutProperties(_ref, ["line", "column"]);

    msg += line ? " (".concat(line, ":").concat(column, ")") : '';
    if (debug) msg += "[Token ".concat(tindex, "]");
    var e = err;
    if (debug) e = new SyntaxError(msg);else err.message = msg;
    throw Object.assign(e, extra);
  }

  var is = function is(type) {
    return function () {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tok;
      return t && t.type === type;
    };
  };

  var isIdentifier = is(T_IDENTIFIER);
  var isText = is(T_TEXT);
  var isWhitespace = is(T_WHITESPACE);
  var isBlockStart = is(T_BLOCK_START);
  var isBlockStop = is(T_BLOCK_STOP);
  var isBracketOpen = is(T_BRACKET_OPEN);
  var isBracketClose = is(T_BRACKET_CLOSE);
  var isParenOpen = is(T_PAREN_OPEN);
  var isParenClose = is(T_PAREN_CLOSE);
  var isAssignment = is(T_ASSIGNMENT);
  var isLiteralNum = is(T_LITERAL_NUM);
  var isLiteralStr = is(T_LITERAL_STR);
  var isLiteralPri = is(T_LITERAL_PRI);

  var isLiteral = function isLiteral() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tok;
    return isLiteralNum(t) || isLiteralStr(t) || isLiteralPri(t);
  };

  function descendBlock(raw) {
    var isRoot = false;

    if (!tok) {
      isRoot = true;
    } else if (!isIdentifier()) wtf("Block helpers must start with a variable identifier, found \"".concat(tok.contents, "\" (").concat(T[tok.type], ")"));

    var block = new Block({
      type: isRoot ? 'ROOT' : contents,
      invoker: isRoot ? null : descendInvocation(),
      left: []
    });
    if (raw) block.raw = raw;
    var children = block.left;

    while (next()) {
      if (isText()) {
        children.push(new Text(contents));
        continue;
      }

      if (isBlockStart()) {
        var r = tok.raw;

        if (next(T_BLOCK_OPEN)) {
          next();
          children.push(descendBlock(r));
        } else if (next(T_ELSE)) {
          if (!children.length) children.push(new Text());
          children = block.right = [];

          while (next(T_WHITESPACE)) {
          } // allow whitespace in the end of closing tags


          next(T_BLOCK_STOP, "Expected }}, found \"".concat(tok.contents, "\" (").concat(T[tok.type], ")"));
        } else if (next(T_BLOCK_CLOSE)) {
          next(T_IDENTIFIER, "The first argument of a block must be an identifier, found \"".concat(tok.contents, "\" (").concat(T[tok.type], ")"));
          if (contents !== block.type) wtf("Expected {{/".concat(block.type, "}} but found {{/").concat(contents, "}}"));
          if (!children.length) children.push(new Text());

          while (next(T_WHITESPACE)) {
          } // allow whitespace in the end of closing tags


          next(T_BLOCK_STOP, "Expected }}, found \"".concat(tok.contents, "\" (").concat(T[tok.type], ")"));
          return block;
        } else if (next(T_IDENTIFIER)) {
          children.push(new Block({
            type: contents,
            invoker: descendInvocation(),
            raw: r
          }));
        } else wtf("This shouldn't have happened. \"".concat(peek().contents, "\" (").concat(T[peek().type], ")"));

        continue;
      }

      wtf("Unexpected token while processing block children for {{#".concat(block.type, "}}: \"").concat(tok.contents, "\" (").concat(T[tok.type], ")"));
    }

    if (!isRoot) wtf("Unexpected end of template, unclosed {{#".concat(block.type, "}}"));
    return block;
  }

  function descendInvocation() {
    var embedded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var invocation = new Invocation();
    var children = invocation.arguments;
    var assigning = false;

    do {
      if (children.length && embedded) children[0].critical = true;
      if (isWhitespace()) continue;

      if (isIdentifier()) {
        if (peek(T_BRACKET_OPEN)) {
          if (assigning) {
            invocation.set(assigning, descendCompoundIdent(contents));
            assigning = false;
          } else {
            children.push(descendCompoundIdent(contents));
          }
        } else if (assigning) {
          invocation.set(assigning, new Identifier(contents));
          assigning = false;
        } else {
          children.push(new Identifier(contents));
        }

        continue;
      }

      if (isBlockStop()) {
        if (children.length > 1) children[0].critical = true;
        return invocation;
      }

      if (!children.length) wtf("Block helpers must start with a variable identifier, found \"".concat(tok.contents, "\" (").concat(T[tok.type], ")"));

      if (isParenOpen()) {
        next();

        if (assigning) {
          invocation.set(assigning, descendInvocation(true));
          assigning = false;
        } else {
          children.push(descendInvocation(true));
        }

        continue;
      }

      if (isLiteral()) {
        if (assigning) {
          invocation.set(assigning, new Literal(contents, tok.type));
          assigning = false;
        } else {
          children.push(new Literal(contents, tok.type));
        }

        continue;
      }

      if (isBracketOpen()) {
        if (assigning) {
          invocation.set(assigning, descendCollection());
          assigning = false;
        } else {
          children.push(descendCollection());
        }

        continue;
      }

      if (assigning) wtf();

      if (isParenClose()) {
        if (!embedded) wtf();
        return invocation;
      }

      if (isAssignment()) {
        var last = children.pop();
        assigning = last.target;
        continue;
      }

      wtf();
    } while (next());

    if (embedded) wtf('Unexpected end of token stream, unclosed nested invocation.');
    return invocation;
  }

  function descendCompoundIdent(initial) {
    var ident = new CompoundIdentifier(initial);
    var ref = false;

    while (next()) {
      if (isWhitespace()) {
        break;
      }

      if (isBracketClose()) {
        var nt = peek(); // ]. or ][ is a continuation of the cIdent

        if (isBracketOpen(nt) || isIdentifier(nt)) {
          continue;
        }

        break;
      }

      if (isIdentifier()) {
        if (next(T_BRACKET_OPEN)) {
          ident.pushRef(descendCompoundIdent(contents));
        }

        if (ref) {
          ref = false;
          ident.pushRef(new Identifier(contents));
        } else {
          ident.pushTarget(contents);
        }

        var _nt = peek();

        if (isBracketOpen(_nt) || isBracketClose(_nt)) {
          continue;
        }

        break;
      }

      if (isParenOpen()) {
        ident.pushRef(descendInvocation(true));
        continue;
      }

      if (isLiteral()) {
        ident.pushTarget(new Literal(contents, tok.type));
        continue;
      }

      if (isBracketOpen()) {
        ref = true;
        continue;
      }

      break;
    }

    return ident;
  }

  function descendCollection() {
    var collection = new Collection();
    var children = collection.arguments;

    while (next()) {
      if (isWhitespace()) continue;

      if (isBracketClose()) {
        return collection;
      }

      if (isParenOpen()) {
        children.push(descendInvocation(true));
        continue;
      }

      if (isIdentifier()) {
        if (next(T_BRACKET_OPEN)) {
          children.push(descendCompoundIdent(contents));
        } else {
          children.push(new Identifier(contents));
        }

        continue;
      }

      if (isLiteral()) {
        children.push(new Literal(contents, tok.type));
        continue;
      }

      if (isBracketOpen()) {
        children.push(descendCollection());
        continue;
      }

      wtf();
    }

    wtf('Unexpected end of token stream, unclosed collection.');
  }

  var result = descendBlock();
  if (!tokens.eof) wtf('There are still tokens left, how did we get here?');
  return result;
}/**
 * Evaluates the block contents if the passed input is truthy.
 *
 * @category default
 *
 * @signature {{#if input [target]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/if}}
 * @param  {mixed} input Value to test.
 * @param  {mixed} target Value to test against (strict equality). If omitted, helper will check if `input` is truthy.
 * @example
 * // name = { first: 'John', last: 'Doe' }
 * {{#if name}}<span>{{first}} {{last}}</span>{{/if}}
 * // Result: <span>John Doe</span>
 */

function _if() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length < 1) throw new Error('Helper "if" needs a minimum of 1 arguments');

  var _args$pop = args.pop(),
      ctx = _args$pop.ctx,
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  var value = args.shift();
  var result = args.length ? value === args[0] : truthy(value);
  if (!fn) return result || '';
  return result ? fn(ctx) : inverse && inverse();
}/**
 * Evaluates the block contents with a new scope.
 *
 * @category default
 *
 * @signature {{#with input}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/with}}
 * @example
 * // name = { first: 'John', last: 'Doe' }
 * {{#with name}}<span>{{first}} {{last}}</span>{{/with}}
 * // Result: <span>John Doe</span>
 */

function _with() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _args$pop = args.pop(),
      env = _args$pop.env,
      fn = _args$pop.fn,
      inverse = _args$pop.inverse,
      hash = _args$pop.hash;

  if (!fn && !inverse) return '';
  if (!args.length) return '';
  var ctx = args[0];
  var frame = makeContext(ctx, env, {
    hash: hash
  });
  return truthy(ctx) ? fn(ctx, frame) : inverse && inverse();
}/**
 * Tests if all of the values in the provided array or object are truthy.
 * May be used inline or as a conditional block.
 *
 * @category collections,logic,default
 * @signature {{all input}}
 * @param  {array<mixed>|object<mixed>} input Array whose values must all be truthy,
 * or an object whose properties must all be truthy
 * @return {boolean}
 *
 * @signature {{#all input}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/all}}
 * @example
 * {{#all flags}}All flags are true.{{else}}Some or none of the flags are true.{{/all}}
 *
 * @signature {{all arg1 [... argN]}}
 * @param {mixed} [argN] Some value to be checked for truthiness
 * @return {mixed} Returns the first last argument if all are truthy, or else an empty string.
 *
 * @signature {{#all arg1 [... argN]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/all}}
 * @describe Truthy block will evaluate if all values are truthy. ({this}).
 * @param {mixed} [argN] Some value to be checked for truthiness
 */

function all$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _args$pop = args.pop(),
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  if (!args.length) {
    throw new Error('Helper "all" needs 1 parameter');
  }

  var result = all.apply(void 0, args);
  if (!fn) return result || '';
  return result ? fn(result) : inverse && inverse(this);
}/**
 * Tests if any of the values in the provided array or object are truthy.
 * May be used inline or as a conditional block.
 *
 * @category collections,logic,default
 * @signature {{any input}}
 * @param  {array<mixed>|object<mixed>} input Array containing any truthy
 * values, or an object with any property that is truthy
 * @return {boolean}
 *
 * @signature {{#any input}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/any}}
 * @example
 * {{#any flags}}Sore or all flags are true.{{else}}None of the flags are true.{{/any}}
 *
 * @signature {{any arg1 [... argN]}}
 * @param {mixed} [argN] Some value to be checked for truthiness
 * @return {boolean} Returns the first truthy value, or an empty string.
 *
 * @signature {{#any arg1 [... argN]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/all}}
 * @describe Truthy block will evaluate if any of the values are truthy.
 * @param {mixed} [argN] Some value to be checked for truthiness
 */

function any() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _args$pop = args.pop(),
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  if (!args.length) {
    throw new Error('Helper "any" needs 1 parameter');
  }

  var input;

  if (args.length > 1) {
    input = args;
  } else {
    input = arrayify(args[0]);
  }

  var result = false;

  var _iterator = _createForOfIteratorHelper(input),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;

      if (truthy(value)) {
        result = value;
        break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (!fn) return result || '';
  return result ? fn(result) : inverse && inverse();
}/**
 * Evaluates the block contents for each item in a collection.
 * May be used inline or as an iterator.
 *
 * @category collections,logic,default
 *
 * @signature {{#each input [count]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/each}}
 * @example
 * // items = ['a','b','c','d','e','f']
 * {{#each items 2}}<span>{{this}}</span>{{/each}}
 * // Result: <span>c</span><span>d</span><span>e</span><span>f</span>
 */

function each(collection) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var _args$pop = args.pop(),
      env = _args$pop.env,
      fn = _args$pop.fn,
      inverse = _args$pop.inverse,
      hash = _args$pop.hash;

  var c = sizeOf(collection);
  if (!c) return inverse ? inverse() : collection;
  if (!fn) return collection;
  return contextIterate(collection, env, fn, hash);
}/**
 * Returns the value at the object path defined via arguments
 * @category objects
 *
 * @signature {{get object path}}
 * @param  {object} value Value to test
 * @param  {string|Array<string>} path Path of the value to retrieve
 * @return {mixed}
 *
 * @signature {{#get value}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/get}}
 * @describe Truthy block will evaluate with the result value as the current context ({this}).
 */

function get$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length < 3) {
    throw new Error('Helper "get" needs a minimum of 3 arguments');
  }

  var _args$pop = args.pop(),
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  var value = args.shift();
  if (!value) return '';

  if (args.length === 1) {
    args = args[0];
  } else {
    args = flatten(args);
  }

  var result = get(value, args, MISSING);
  if (result === MISSING) return inverse ? inverse() : '';
  return fn ? fn(result) : result;
}/**
 * Tests if a value exists at the object path defined via arguments
 * @category objects
 *
 * @signature {{get object path}}
 * @param  {object} value Value to test
 * @param  {string|Array<string>} path Path of the value to retrieve
 * @return {boolean}
 *
 * @signature {{#has value}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/has}}
 * @describe Truthy block will evaluate with the result value as the current context ({this}).
 */

function has$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length < 3) {
    throw new Error('Helper "has" needs a minimum of 3 arguments');
  }

  var _args$pop = args.pop(),
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  var value = args.shift();

  if (args.length === 1) {
    args = args[0];
  } else {
    args = flatten(args);
  }

  var result = has(value, args);
  if (!fn) return result || '';
  return result ? fn() : inverse && inverse();
}/**
 * Tests if the first argument matches any of the other arguments with strict equality.
 *
 * @category logic,default
 *
 * @signature {{is value test1 ... testN}}
 * @param  {mixed} value Value to check against
 * @param  {mixed} ...test Values to test
 * @return {mixed} Matched value
 *
 * @signature {{#is value test1 ... testN}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/is}}
 * @describe Truthy block will evaluate with the result value as the current context ({this}).
 */
function is() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length < 3) throw new Error('Helper "is" needs a minimum of 2 arguments');

  var _args$pop = args.pop(),
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  var value = args.shift();
  var result = args.includes(value);
  if (!fn) return result || '';
  return result ? fn(this) : inverse && inverse(this);
}/**
 * Tests that the first argument does not match any of the other arguments with strict equality.
 * @category logic,default
 *
 * @signature {{isNot value test1 ... testN}}
 * @param  {mixed} value Value to check against
 * @param  {mixed} ...test Values to test
 * @return {mixed} Matched value
 *
 * @signature {{#isNot value test1 ... testN}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/isNot}}
 */
function isNot() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length < 3) {
    throw new Error('Helper "isNot" needs a minimum of 2 arguments');
  }

  var _args$pop = args.pop(),
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  var value = args.shift();
  var result = args.indexOf(value) === -1;
  if (!fn) return result || '';
  return result ? fn() : inverse && inverse();
}/**
 * Sends the passed arguments to console.log
 * @name log
 * @category debug
 *
 * @signature {{log}}
 * @return {null} Sends the current context to console.log
 *
 * @signature {{log argument1 ... argumentN}}
 * @param  {...mixed} args Arguments to send to console.log
 * @return {null}
 */
function log() {
  var _console;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _args$pop = args.pop(),
      env = _args$pop.env;

  if (!args.length) args = [env];

  (_console = console).log.apply(_console, _toConsumableArray(args)); // eslint-disable-line no-console

}
/***//**
 * Evaluates the block contents of the passed input is falsey or equals a target.
 *
 * @category logic,default
 *
 * @signature {{#not input [target]}}<TEMPLATE>[{{else}}<TEMPLATE>]{{/not}}
 * @example
 * @param  {mixed} input Value to test.
 * @param  {mixed} target Value to test against (strict equality). If omitted, helper will check if `input` is falsey.
 * // name = { first: 'John', last: 'Doe' }
 * {{#not name}}No Name Defined{{else}}<span>{{first}} {{last}}</span>{{/not}}
 * // Result: <span>John Doe</span>
 */

function not() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _args$pop = args.pop(),
      ctx = _args$pop.ctx,
      fn = _args$pop.fn,
      inverse = _args$pop.inverse;

  var value = args.shift();
  var result = args.length ? value !== args[0] : falsey(value);
  if (!fn) return result || '';
  return result ? fn(ctx) : inverse && inverse();
}var helpers = {
  if: _if,
  with: _with,
  each: each,
  log: log,
  not: not,
  unless: not,
  has: has$1,
  is: is,
  isNot: isNot,
  all: all$1,
  any: any,
  get: get$1,
  lookup: get$1
};function parse(input) {
  if (isString(input)) return lex(input);
  if (input instanceof Block) return input;
  wtf('Parse can only receive strings or a Handybars AST tree');
}
function evaluate(input, ctx) {
  if (isString(input)) input = lex(input);else if (!(input instanceof Block)) {
    wtf('Evaluate can only receive strings or a Handybars AST tree');
  }
  return input.evaluate(ctx, helpers).value;
}
function Handybars(template) {
  var world = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ast = parse(template);

  var env = _objectSpread2({}, helpers, {}, world);

  function execute(ctx) {
    var frame = makeContext(ctx, env);
    return ast.evaluate(ctx, frame).value;
  }

  execute.set = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (isObject(args[0])) {
      Object.assign.apply(Object, [env].concat(args));
    } else {
      set.apply(void 0, [env].concat(args));
    }

    return execute;
  };

  execute.setPartial = function (name, subtemplate) {
    return set(env, name, lex(subtemplate));
  };

  return execute;
}Object.assign(Handybars, {
  partial: parse,
  parse: parse,
  evaluate: evaluate,
  Text: Text,
  Block: Block,
  Invocation: Invocation,
  Collection: Collection,
  Identifier: Identifier,
  Literal: Literal,
  makeContext: makeContext,
  safe: safe,
  safeJoin: safeJoin
});exports.default=Handybars;Object.defineProperty(exports,'__esModule',{value:true});})));