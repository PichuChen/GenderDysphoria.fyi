/* eslint new-cap:0 */

import lexer from './lexer';
import { stripIndent, isUndefined, isString, map, wtf } from './utils';

import {
	T_LITERAL_NUM,
	T_LITERAL_PRI,
	T_LITERAL_STR,
} from './tokenizer';

export default function compile (input) {
	if (isString(input)) input = lexer(input);
	if (!input._type) wtf('Parse can only receive strings or a Handybars AST tree');
	return (stripIndent`
		import { join, resolve } from 'handybars/runtime';
		export default function (ctx, env) {
			return [replace];
		}
	`).replace('[replace]', parseNode(input));
}

function parseNode (node) {
	return (parseNode.map[node._type] || (() => ''))(node);
}

parseNode.map = {
	Node,
	Text,
	Block,
	Invocation,
	Collection,
	Identifier,
	CompoundIdentifier,
	Literal,
};

function Node () {}

function Text (node) { return node.value ? JSON.stringify(node.value) : undefined; }

function Block (node) {
	function descender (tree) {
		if (!tree || !tree.length) return null;
		return `(ctx, env) => join(\n\t${tree.map(parseNode).filter(Boolean).join(',\n\t')}\n)`;
	}
	const left = descender(node.left);
	const right = descender(node.right);

	if (!left && !right) {
		return Invocation(node.invoker);
	}

	if (left && !node.invoker) return left;

	const hash = Invocation.hash(node.invoker);
	return 'block({' + [
		'ctx',
		'env',
		hash ? 'hash:' + hash : false,
		left ? `left:${left}` : false,
		right ? `right:${right}` : false,
		node.invoker.arguments.length ? `args:${Invocation.args(node.invoker)}` : false,
	].filter(Boolean).join(', ') + '})';
}

function Invocation (node) {
	const hash = Invocation.hash(node);
	return 'exe({' + [
		'ctx',
		'env',
		hash ? 'hash:' + hash : false,
		node.arguments.length ? `args:${Invocation.args(node)}` : false,
	].filter(Boolean).join(', ') + '})';
}

Invocation.hash = function (node) {
	if (!node.hashCount) return null;
	return '{' +
		map(node.hash, (segment, key) => `${key}:${parseNode(segment)}`).join('') +
		'}';
};

Invocation.args = function (node) {
	return '[' + node.arguments.map(parseNode).filter(Boolean).join(', ') + ']';
};

function Collection (node) {
	return `[${node.arguments.map(parseNode).filter(Boolean).join(', ')}]`;
}

function Identifier (node) {
	return `resolve(ctx, env, ${JSON.stringify(node.target)}${node.critical ? ', true' : ''})`;
}

function CompoundIdentifier (node) {
	const path = node.path.map((segment) => {
		if (!isUndefined(segment.ref)) {
			return parseNode(node.refs[segment.ref]) || undefined;
		}

		if (segment.evaluate) {
			return parseNode(segment);
		}

		return undefined;
	}).filter((v) => !isUndefined(v));

	return `resolve(ctx, env, [ ${path.join(', ')} ]${node.critical ? ', true' : ''})`;
}

function Literal (node) {
	switch (node.type) {
	case T_LITERAL_NUM:
		return 'parseFloat(' + JSON.stringify(node.value) + ')';
	case T_LITERAL_STR:
	case T_LITERAL_PRI:
		return JSON.stringify(node.value);
	default:
		return undefined;
	}
}
