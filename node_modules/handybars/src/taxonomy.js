
import { get, wtf, isPrimitive, isFunction, isUndefinedOrNull, safe, mapValues, makeContext, MISSING } from './utils';

import {
	T_LITERAL_NUM,
	T_LITERAL_PRI,
} from './tokenizer';

export class Node {
	constructor () { this._type = 'Node'; }
	evaluate () { return null; }
}

export class Text extends Node {
	constructor (value = '') {
		super();
		this.value = value;
		this._type = 'Text';
	}

	evaluate () {
		return { value: this.value };
	}
}

export class Block extends Node {
	constructor ({ type, invoker, left, right, raw, ...props }) {
		super();
		Object.assign(this, props);
		this.type = type;
		this.invoker = invoker || null;
		this.left = left || null;
		this.right = right || null;
		this.raw = raw || false;
		this._type = 'Block';
	}

	_descender (tree, ctx, env) {
		if (!tree || !tree.length) return null;
		return (subctx = ctx, e = env) => {
			if (e === env && subctx !== ctx) e = makeContext(subctx, e);
			return render(tree, subctx, e);
		};
	}

	evaluate (ctx, env = {}) {
		const fn = this._descender(this.left, ctx, env);
		const inverse = this._descender(this.right, ctx, env);
		const children = this.left && this.left.length ? this.left : null;

		var result = this.invoker
			? this.invoker.evaluate(ctx, env, { fn, inverse, children })
			: fn && fn(ctx) || undefined
		;

		return this.raw ? safe(result) : safe.up(result);
	}
}

export class Invocation extends Node {
	constructor (props = {}) {
		super();
		Object.assign(this, props);
		this.arguments = props.arguments || [];
		this.hash = props.hash || {};
		this._type = 'Invocation';
	}

	evaluate (ctx, env = {}, { fn, inverse, children } = {}) {
		if (!this.arguments.length) return ''; // this shouldn't happen
		let [ target, ...args ] = this.arguments;
		target = target.evaluate(ctx, env);

		const hash = this.hashCount ? mapValues(this.hash, (a) => safe.down(a.evaluate(ctx, env))) : {};

		if (target && isFunction(target.evaluate)) {
			const source = args.length ? args[0] : ctx;
			const frame = makeContext(source, env, { hash });
			if (children) frame['@partial-block'] = new Block({ type: '@partial-block', left: children });
			return target.evaluate(source, frame);
		}

		if (!isFunction(target)) {
			if (target && fn) return fn(ctx, env);
			if (!target && inverse) return inverse(ctx, env);
			if (fn && inverse) return target ? fn(ctx, env) : inverse(ctx, env);
			return target;
		}

		args = args.map((a) => safe.down(a.evaluate(ctx, env)));
		return target(...args, {
			ctx,
			env,
			fn,
			inverse,
			arguments: args,
			hash,
			resolve: (what) => resolve(what, ctx, env),
		});
	}

	set (key, value) {
		this.hash[key] = value;
		this.hashCount = (this.hashCount || 0) + 1;
		return this;
	}
}

export class Collection extends Invocation {
	constructor (args) {
		super();
		this.arguments = args || [];
		this._type = 'Collection';
	}

	evaluate (ctx, env = {}) {
		return this.arguments.map((a) => a.evaluate(ctx, env));
	}
}

export class Identifier extends Node {
	constructor (target, critical) {
		super();
		this.target = target;
		this.critical = !!critical;
		this._type = 'Identifier';
	}

	evaluate (ctx, env = {}) {
		return resolve(this.target, ctx, env, this.critical);
	}
}

export class CompoundIdentifier extends Node {
	constructor (target, args = [], critical = false) {
		super();
		this.path = target.split(/[,[\].]+?/).filter(Boolean).map((i) => new Identifier(i));
		this.refs = [];
		this.critical = critical;
		this._type = 'CompoundIdentifier';

		for (const arg of args) {
			if (arg.r) this.pushRef(arg.r);
			else this.pushTarget(arg);
		}
	}

	evaluate (ctx, env = {}) {
		const refs = this.refs.map((spec) => safe.down(spec.evaluate(ctx, env, this.critical)));
		const path = this.path.map((spec) => {
			if (spec.ref !== undefined) {
				spec = refs[spec.ref];
			}
			if (spec.evaluate) {
				return safe.down(spec.evaluate(ctx, env, this.critical));
			}
			return spec;
		});

		const target = path.shift();
		if (!target) return;

		const result = get(target, path, MISSING);
		return result === MISSING ? undefined : result;
	}

	pushRef (spec) {
		this.refs.push(spec);
		this.path.push({ ref: this.refs.length - 1 });
	}

	pushTarget (spec) {
		this.path.push(spec);
	}
}

export class Literal extends Node {
	constructor (value, type = T_LITERAL_PRI) {
		super();
		this.value = value;
		this.type = type;
		this._type = 'Literal';
	}

	evaluate () {
		if (this.type === T_LITERAL_NUM) return parseFloat(this.value);
		return this.value;
	}
}

function render (children, ctx, env) {
	if (!Array.isArray(children) || !children.length) return '';
	const value = children
		.map((c) => safe.up(c.evaluate(ctx, env)))
		.filter((c) => c.value !== '')
		.map((c) => c.value)
		.join('');
	return { value };
}


function resolve (what, ctx, env, needed = false) {
	let target;
	if (!isUndefinedOrNull(ctx)  && !isPrimitive(ctx) && (target = get(ctx, what, MISSING)) !== MISSING) return target;
	if (!isUndefinedOrNull(env)    && (target = get(env, what, MISSING)) !== MISSING) return target;

	let parent = env;
	while ((parent = parent['@parent'])) {
		if (!isUndefinedOrNull(parent.this) && !isPrimitive(parent.this) && (target = get(parent.this, what, MISSING)) !== MISSING) return target;
		if (!isUndefinedOrNull(parent)      && (target = get(parent, what, MISSING)) !== MISSING) return target;
	}

	if (needed) wtf(`Could not resolve "${what}"`);
	return;
}

export default {
	Node,
	Text,
	Block,
	Invocation,
	Collection,
	Identifier,
	CompoundIdentifier,
	Literal,
};

